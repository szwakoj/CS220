{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CS220 - Computer Organization","text":"<p>Welcome to CS 220, Spring 2026!</p> <p>This site serves as the main entry point for the course and will be the means of distributing course material. All information on here will be translated to Brightspace for grades, due dates, and handing in assignments.</p> <p>Important links:</p> <ul> <li>Syllabus - Syllabus of the course, containing critical information about the course</li> <li>Schedule - Course schedule; use primarily as a history of topics, launching point, and 1-2 week look ahead</li> <li>Lessons - The main repository of course material, all lectures are based on these</li> <li>Homeworks - This link takes you to the details of how to hand in homework, as well as all currently given assignments</li> <li>Labs - The course's guided labs, optional and initiated in-person, with students finishing at home</li> </ul> <p>Note on Accessibility</p> <p>This course website was adopted and hand tailored to be in-line with new WCAG accessibility guidelines. If there are any issues accessing its material or if there are features not working properly, please reach me at szwakoj@sunypoly.edu with the subject line \"CS 220 Site Issue\".</p> <p>In addition to offering all course material in this format, the source plain text, markdown files are available at this course's github to be viewed through your markdown viewer of choice. </p>"},{"location":"glossary/","title":"Glossary","text":"<p>Quick reference meanings for the course. Note, these are not complete and accepted formal definitions. </p> <p>Computer (historical) - At its most basic, \"a thing that computes\"; originally referred to humans who would sit at desks and do repeated numerical calculations for businesses and institutions.</p> <p>Digital Computer - Modern devices that use discrete numbers to symbolically represent information and perform operations on that data using a finite set of general operations. Made of transistors that form logic gates.</p> <p>Analog Computer - Devices that model predetermined calculations through the use of voltage, gears, pulleys, or other phenomenon that is related to the calculation in question.</p> <p>Purpose Built - A characteristic of analog computers meaning they cannot be reprogrammed and must have their purpose defined beforehand.</p> <p>Transistor - Small electrical components that can either block or allow passage of an electrical signal depending on whether itself is being fed an electrical signal. Used to make logic gates in modern computers.</p> <p>Universal Turing Machine - A theoretical general-purpose computer proposed by Alan Turing in 1936, capable of computing anything that is computable by executing instructions stored in memory.</p> <p>Turing-complete - A device that can simulate a Turing machine by being able to: read and write data to memory, perform conditional branching, loop or repeat operations, and have the possibility of infinite memory.</p> <p>Bit - The smallest unit of information, having two states (on and off) that map directly to True and False, 1 and 0.</p> <p>Logic Gates - Components built from transistors that use boolean algebra; they bridge the gap between natural electrical phenomenon and more complex computing systems.</p> <p>Abstraction Hierarchy - Layered diagrams used by computer scientists to organize the many logical structures that build on top of one another in a computer system, from electronics/physics up to applications.</p> <p>Von Neumann Architecture (Von Neumann Model) - The main architecture used for modern computers, organizing logic gates into components with concrete purposes to build a general computing platform. Falls at the \"Micro Architecture\" layer of the abstraction hierarchy.</p> <p>Central Processing Unit (CPU) - The main computational workhorse that reads machine instructions and executes them. Made of two parts: the Control Unit and Arithmetic/Logic Unit.</p> <p>Control Unit - Part of the CPU used to sequence operations to be performed by the machine, orchestrating the other components.</p> <p>Arithmetic/Logic Unit - Part of the CPU used to perform the instructions from the control unit on the memory unit.</p> <p>Memory Unit - A bank of memory that stores both instructions and data in the same address space.</p> <p>Input Device - The source of information into the CPU, can be new instructions or data.</p> <p>Output Device - Receives information from the CPU and routes it to other devices for control signals.</p> <p>Instruction Set Architecture (ISA) - Defines what instructions exist for the CPU to execute; these instructions are what become machine code.</p> <p>Machine Code - The individual instructions executed by the CPU, stored and read in raw binary.</p> <p>Assembly Language - A system of writing CPU instructions using human-readable identifiers (characters that relate to the instruction's purpose) instead of raw binary, making direct communication with the CPU easier.</p> <p>Assembler - A program that can convert assembly code into binary machine code that the CPU can understand and execute.</p>"},{"location":"schedule/","title":"Schedule","text":""},{"location":"schedule/#disclaimer","title":"DISCLAIMER","text":"<p>This schedule will be primarily used as a history of topics that we have covered thus far, as well as a short look into the future. To best attend to the class' pace, future looks will be limited to 1-2 weeks ahead with all due dates known when assignments are given and quiz/test dates when they are announced. Any changes made to significant dates will be in the students favor, if they happen. </p> Date Topic Lessons Labs Homework 1/19/26 (Week 1) - Syllabus 1/26/26 (Week 2) - Introduction- History Introduction 2/2/26 (Week 3) - C Review- Binary C Review - Homework 1 : C Review (Due 2/13/26) (Released 2/1/26) 2/9/26 (Week 4) - Binary Operations"},{"location":"syllabus/","title":"Syllabus","text":""},{"location":"syllabus/#course-computer-organization-cs-220","title":"Course: Computer Organization (CS 220)","text":"<p>Section: 02</p> <p>CRN: 2040</p> <p>Semester: Spring 2026</p> <p>On-Campus, 4 Credits</p> <p>Room: Kunsela Hall A135 </p> <p>Meeting Times: Mondays and Wednesdays, 12:00pm - 1:50pm</p>"},{"location":"syllabus/#office-hours-and-contact-info","title":"Office Hours and Contact Info","text":"<p>Instructor: John Szwakob III (Mr. S)</p> <p>Office Location: Kunsela Hall C127</p> <p>Office Hours: - Mondays 2:00pm - 4:00pm</p> <ul> <li> <p>Tuesdays and Thursdays, 10:00am - 12:00pm</p> </li> <li> <p>Friday by appointment</p> </li> </ul> <p>Phone: (315) 792-7256</p> <p>Note: This is my office phone, I will be in the office guaranteed during the office hours above, however outside of that I may be teaching if you call during school hours. I encourage you to leave a message. The best way to contact me remains through the email below as I can respond much quicker for time sensitive matters.</p> <p>Email: szwakoj@sunypoly.edu</p>"},{"location":"syllabus/#course-catalog-description","title":"Course Catalog Description:","text":"<p>Introduces students to the organization and architecture of computer systems as a hierarchy of levels, beginning with the standard von Neumann model and then moving forward to more recent architectural concepts. Topics include digital logic, microprogramming, conventional machine and assembly language levels. Emphasis is given to those aspects of computer hardware that effect programming. Prerequisite: CS 108</p>"},{"location":"syllabus/#course-objectives","title":"Course Objectives:","text":"<ul> <li>Give a high-level overview of the organization and architecture of computer systems</li> <li>Introduce students to the concept of abstraction in both problem solving and computer systems</li> <li>Cover the von Neuman Architecture</li> <li>Teach students the binary number system, boolean logic, and digital logic</li> <li>Have students program in Assembly and other low-level machine languages</li> <li>Show the intersection of computer hardware and software</li> </ul>"},{"location":"syllabus/#student-learning-outcomes","title":"Student Learning Outcomes","text":"<p>By the end of this course you will:</p> <ul> <li>Understand the concept of abstraction</li> <li>Be able to explain the Hierarchy of Abstraction in computers and understand which level you are working in</li> <li>Know the general organizational and architectural concepts of computer systems at multiple levels</li> <li>Convert numbers between binary, decimal, and hexadecimal number systems</li> <li>Use basic boolean algebra and k-maps to understand digital logic</li> <li>Design basic circuits using logic gates</li> <li>Understand how transistors are used to built up to more complex systems</li> <li>Create your own Fetch-Decode-Execute systems</li> <li>Simulate/Emulate simple CPU processes using bit manipulation in the C programming language</li> <li>Code in Assembly and other low-level instruction sets</li> </ul>"},{"location":"syllabus/#text-and-materials","title":"Text and Materials:","text":"<p>There is no required text book, most if not all material will be through this site and in class lectures. There are, however suggested resources for those who learn best with a textbook as reference, as well as the sources for the course.</p> <p>\"Digital Design and Computer Architecture\" by Harris and Harris </p> <ul> <li> <p>Textbook that covers a lot of the early information of this course, we will not be covering it exhaustively</p> </li> <li> <p>Not required</p> </li> </ul>"},{"location":"syllabus/#course-schedule","title":"Course Schedule:","text":"<p>Below is the rough topical structure of the course in the order of coverage, you can find this plan and the most updated schedule at the course website. The schedule is a rough outline and will be changed to best serve the classes needs, any changes made will be in favor of the students and any complications can be rectified over email or in-person.</p> <p>These units are a rough organization of the topics in the order covered, they will be about 2-3 weeks each with some time allotted for tests and review. More or less time could be taken depending on the class pace, the latter allowing for more topics to be covered.</p> <ul> <li>Unit Order<ul> <li>Introduction</li> <li>Basic Computer Organization</li> <li>Binary and Digital Logic</li> <li>Circuits, Multiplexers, and Decoders</li> <li>Instruction Set Architectures and Assembly</li> </ul> </li> </ul>"},{"location":"syllabus/#method-of-evaluation","title":"Method of Evaluation","text":"<ul> <li>Homeworks <ul> <li>Take home assignments meant to instill concepts covered in class</li> <li>Will often be based on labs or other in-class activities</li> <li>Mostly coding, short answer, and some drawing</li> </ul> </li> <li>Attendance Quizzes<ul> <li>Short (2-3 Questions) in-person quizzes given weekly</li> <li>Meant to test topics covered the class previous</li> <li>Can be given on any class day during the week</li> <li>No re-tests</li> <li>Three lowest grades dropped from average</li> </ul> </li> <li>Unit Tests<ul> <li>Longer form (10 - 15 Questions) in-person tests given at the end of each unit</li> <li>Given about every three weeks, announced beforehand</li> <li>Will contain short and long answer questions</li> <li>Based on lesson, homeworks, labs, and attendance quizzes</li> <li>Retests given sparingly and under adequate circumstances</li> <li>Lowest grade dropped from average</li> </ul> </li> <li>Labs<ul> <li>Ungraded guided exercises that are covered in class </li> <li>Students will start them in class and finish them on their own</li> <li>Will prepare students for both homeworks and tests</li> </ul> </li> </ul> Academic Work % of Grade Homework 60% Attendance Quizzes(Weekly) 10% Unit Tests 30% Labs(in-class) Ungraded Total 100%"},{"location":"syllabus/#letter-grading","title":"Letter Grading","text":"Letter Grade Percentage Range A+ 96\u2154 - 100% A 93\u2153 - 96\u2154% A- 90 - 93\u2153% B+ 86\u2154 - 90% B 83\u2153 - 86\u2154% B- 80 - 83\u2153% C+ 76\u2154 - 80% C 73\u2153 - 76\u2154% C- 70 - 73\u2153% D+ 66\u2154 - 70% D 63\u2153 - 66\u2154% D- 60 - 63\u2153% F 0 - 60%"},{"location":"syllabus/#accommodations-for-students-with-accessibility-needs-at-suny-polytechnic-institute","title":"Accommodations for Students with Accessibility Needs at SUNY Polytechnic Institute:","text":"<p>Your access in this course is important to me. In compliance with the Americans with Disabilities Act of 1990 and Section 504 of the Rehabilitation Act of 1973, SUNY Polytechnic Institute is committed to ensuring comprehensive educational access and accommodations for all registered students seeking access to meet course requirements and fully participate in programs and activities. Students with documented disabilities, temporary, or medical conditions are encouraged to request services by contacting Student Accessibility Services (SAS) or filling out the Request for Accommodations form. Please note, requesting accommodations is only the first step. You must provide documentation (the request form may count) to SAS and meet with staff before receiving accommodations. Please do this as early as possible 1) because accommodations are never retroactive and 2) so that we have adequate time to arrange your approved academic accommodation/s.</p> <p>Once SAS creates your accommodation plan, it is your responsibility to provide me a copy of the accommodation plan. If you experience any access barriers in this course, such as with printed content, graphics, online materials, etc., reach out to me or SAS right away. For information related to these services or to schedule an appointment, please contact SAS using the information provided below.</p>"},{"location":"syllabus/#office-of-student-accessibility-services","title":"Office of Student Accessibility Services","text":"<p>Email: SAS@sunypoly.edu</p> <p>Phone: (315) 792-7170</p> <p>Location: Kunsela Hall, B101</p>"},{"location":"syllabus/#content-accessibility","title":"Content Accessibility","text":"<p>SUNY Poly\u2019s goal is for all digital content to be fully accessible but there may be times when remediation is still underway, please let me know if you experience challenges accessing any digital content in this course.</p> <p>This course is attempting to start a new standard for the CS department using open-source tools to make content universally accessible according to any accessibility requirements by producing all content sources in Markdown. By creating it in Markdown and pure text, any accessibility reader can be tooled to a students needs, while allowing for the teacher to rapidly create material in a lasting way.</p> <p>This process will not be without its bumps, so, if there are any issues with accessing the course material or reading it in any way, please contact me ASAP by email at szwakoj@sunypoly.edu.</p>"},{"location":"syllabus/#pregnancy-statement","title":"Pregnancy Statement","text":"<p>SUNY Poly is committed to fostering an inclusive and supportive environment for all students and it does not discriminate against any student based on the student's pregnancy or related conditions. If you have questions or concerns related to pregnancy or related conditions, please contact the Title IX Coordinator, Kathie Artigiani at artigik@sunypoly.edu.</p>"},{"location":"syllabus/#technical-assistance-for-students","title":"Technical Assistance for Students","text":"<p>The following only applies for technologies and materials offered by the school generally and not the ones that this course uses individually. If there are any issues with the course website, programming tools, or homeworks, email the teacher.</p> <p>The SUNY Poly Help Desk is in the Cayan Library on the first floor. You can contact them by phone at 315-792-7440, by email at helpdesk@sunypoly.edu, or by submitting an online help ticket on their website.</p> <p>If the SUNY Poly Help Desk is closed, you can obtain assistance from the Open SUNY Help Desk by calling 1-844-OPENSUNY (673-6786). The Open SUNY email is OpenSUNYHelp@suny.edu or you can submit an online help ticket.</p> <p>The SUNY Poly ITS website has information about software and hardware that you can access as a student, as well as links to software you may need in your classes. Students are encouraged to save all work in multiple locations. MS Office OneDrive is available for use. For assistance, please contact the ITS Help Desk, helpdesk@sunypoly.edu or 315-792-7440. </p>"},{"location":"syllabus/#academic-integrity-and-code-of-conduct","title":"Academic Integrity and Code of Conduct","text":"<p>SUNY Poly is committed to academic excellence in a climate of honesty, respect, and trust. The mutually respectful exchange of honest ideas is foundational to the intellectual vigor of the SUNY Poly community. The University seeks to maintain and enhance its educational environment through the development, promotion, and enforcement of standards for academic integrity. Please take a few minutes to become familiar with SUNY Poly\u2019s Community Standards, including the Student Handbook and Student Code of Conduct. SUNY Poly\u2019s Academic Integrity Policy, which describes SUNY Poly\u2019s policies regarding plagiarism and other inappropriate academic activities, can be found in the Student Handbook. </p>"},{"location":"syllabus/#writing-and-communications-center","title":"Writing and Communications Center","text":"<p>The Writing and Communications Center (WCC) is here to support all of SUNY Poly\u2019s writers: students, faculty, and staff. We offer one-on-one in-person and remote consultations for writers working on a range of projects at any stage of the writing process (from idea generation to final revisions). WCC consultants work with writers on idea development, brainstorming, content development, structure, source use, style, grammar, punctuation, and more. While we are not a proofreading or editing service and we do not comment on grades, we offer strategies and resources writers can use as they compose, revise, edit, and learn to proofread their own work. The WCC is located on the first floor of the Cayan Library. You can learn more about the WCC or make an appointment by visiting our website: https://sunypoly.edu/writingcenter.html.</p>"},{"location":"syllabus/#plagiarism-warning","title":"Plagiarism Warning","text":"<p>All homeworks, quizzes, tests, and labs are meant to be completed by students independently (unless otherwise stated) and without the assistance of generative AI backed by LLMs including, but not limited to, ChatGPT, Claude, Gemini, and all other text/code generators. All material that is assigned to students is meant to instill lasting critical thinking and problem solving skills that are required to excel in both this course and wherever students may end up in the future. As such, usage of these tools in a fashion akin to plagiarism (not citing, wholesale copying, intent to hide sources) is strictly prohibited in this course. All incidents that can be proven must be brought to the dean and always results in a zero on the grade. This goes for plagiarizing code from other sources, such as StackOverflow, Reddit, Github, other uncited sources, and fellow students.</p> <p>That being said, using other sources as reference is not completely out of the question. Peers, tutorials, YouTube videos, existing code, and even LLMs can greatly aid in understanding complex topics. However, they cannot be used without disclosure and proper citation if being used extensively in an assignment. Use other sources and LLMs cautiously as this course is based on the lessons found within the the lectures given in-person.</p>"},{"location":"syllabus/#policy-on-submission-of-assignments","title":"Policy on Submission of Assignments","text":"<p>All assignments will be submitted via Brightspace in the appropriate location identified by each assignment. Specific instructions can be found on the course website. Each assignment will be given with an intended due date attached. For each day late an assignment is, a 10% reduction will be removed from the maximum possible grade, capped at 50%, so long as a valid final submission has been made by the end of the semester.</p>"},{"location":"syllabus/#policy-on-missed-classes-make-up-work-andor-extra-credit","title":"Policy on Missed Classes, Make-up Work, and/or Extra Credit:","text":"<p>There is no method of attendance other than the attendance quizzes given weekly</p>"},{"location":"syllabus/#cancellation-of-classes-due-to-inclement-weather-or-other-emergency","title":"Cancellation of Classes Due to Inclement Weather or Other Emergency:","text":"<p>SUNY Poly has a 24-hour hotline, called Snowline, to inform students, faculty, and staff when severe weather prompts the cancellation of all classes. Snowline can be reached by calling 315-792-7385. In the event of severe weather, Snowline will announce only the cancellation of ALL classes. The cancellation of all classes will also be posted online and broadcast on radio and television stations in the Utica Rome and Syracuse areas. The SUNY Poly website also maintains a list of individual class cancellations.</p> <p>In addition, all SUNY Poly students and employees are enrolled in the Rave Alert emergency alert service. You can visit the SUNY Poly Rave Alert website to learn more and to adjust your notification preferences. </p>"},{"location":"homework/1_c_review/","title":"C Review: Binary Image Memory Reading/Writing","text":""},{"location":"homework/1_c_review/#due-date-22026","title":"Due Date: 2/20/26","text":""},{"location":"homework/1_c_review/#description","title":"Description","text":"<p>In this homework, you will be learning to manipulate information using raw binary. In order to visualize the various binary operations we are doing, we will be using the PBM/PGM/PPM  image formats as a way of quickly writing pixel information directly to memory.</p> <p>For more info on the PBM/PGM/PPM file format, the Wikipedia page for them is a pretty good resource along side the specifications that I could find:</p> <ul> <li>Netpbm Wikipedia Page</li> <li>Netpbm Specifications<ul> <li>PBM Spec</li> <li>PGM Spec</li> <li>PPM Spec</li> </ul> </li> </ul> <p>The spark notes version is that \"Netpbm\" or \"Network Portable Bitmap Format\" is a collection of tools and specifications for portable graphics file formats. They have three main types of portable formats that can be opened by nearly any text editor:</p> <ul> <li>PBM (Portable BitMap Format) - Each pixel is either a 1 or 0, for white or black respectively</li> <li>PGM (Portable GreyMap Format) - Typically, each pixel can be any number between 0-255 signifying how grey the pixel is, with 0 being black and 255 being white</li> <li>PPM (Portable PixMap Format) - Each pixel now has three numbers ranging from 0-255, for each red, green, and blue color channels</li> </ul> <p>Each type of file defines ways of writing pixels to an image file in a very general way, it is so general I can show the raw form of the file format. The basic one, PBM, binary numbers, 0 to turn off a pixel and 1 to turn it on. The following .pbm file stores a happy face:</p> <pre><code>P1\n10 10\n1\n0 0 0 0 0 0 0 0 0 0\n0 0 1 0 0 0 0 1 0 0\n0 0 1 0 0 0 0 1 0 0\n0 0 1 0 0 0 0 1 0 0\n0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 0 0 0 1\n0 1 0 0 0 0 0 0 1 0\n0 0 1 1 1 1 1 1 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n</code></pre> <p>Let's explain line-by-line:</p> <ol> <li><code>P2</code> - This is the \"magic number\" it ultimately decides what format we are using. <code>P2</code> specifically refers to the Portable GreyMap Format in ascii, rather than in raw bytes, more on this later.</li> <li><code>10 10</code> -  After the magic number, there is two numbers to represent the width and height in that order. These are used to read the rest of the file, automatically making sure that each pixel is put in the correct location.</li> <li><code>1</code> - This is the scale of all of the numbers, this is saying that the grey scale is maxed at 1 meaning there is only black, 0, and white 1</li> <li><code>0 0 0 0 ...</code> - This is the actual contents of the file. For black and white grey scale images each number represents the value for that pixel to be drawn to the screen.</li> </ol> <p>That \"magic number\" is the format that is used for identifying how the data will be stored, either as ascii chars that are viewable, or raw binary format for being compact and closer to reality. These are the magic numbers for <code>.pbm</code>, <code>.pgm</code>, and <code>.ppm</code> - <code>P1</code>, <code>P2</code>, <code>P3</code> = ASCII format (human-readable) - <code>P4</code>, <code>P5</code>, <code>P6</code> = Raw binary format (more compact)</p> <p>Fortunately, Sublime Text and other text editors like VSCode and view this images as they live update. Unfortunately, Sublime Text only supports it for <code>.pgm</code> and <code>.ppm</code> and only in magic number modes <code>P5</code> and <code>P6</code>, meaning you will only be able to view the ones after you have generated in binary. With this in mind, we will be focusing on <code>.pgm</code> and <code>.ppm</code> and be generating in raw binary and then viewing the files.</p> <p>These types of files were picked for this assignment because they are a simple format that represents very closely to how we write directly to memory. With this in mind, we will only be allowing the the use of C binary and hexadecimal numbers for all values other than powers of 2 (0, 1, 2, 4, 8, 16, ...) and heavily relying on C binary/bitwise operators.</p> <p>To use C binary and hexadecimal number representations: - Prefix with <code>0b</code> for binary numbers     - <code>0b1010</code> for the number 10 - Prefix with <code>0x</code> for hex numbers     - <code>0xABC</code> for the number 2748</p> <p>Using these ideas in this homework you will: - Write/edit simple binary images in black and white - Write more complex color images</p> <p>Section 1: Black and White &amp; Greyscale Images - Random Noise (BW and Greyscale) - Bit-Plane an Image - Bitwise Patterns Section 2: Color Images - Random Noise  - Bitwise Patterns - Bit-Plane an Image - Color Channel Fragmentation and Mixing</p>"},{"location":"homework/1_c_review/#section-1-black-and-white-greyscale-images","title":"Section 1: Black and White &amp; Greyscale Images","text":"<p>Click here, to download the starting point that I have created for you. It is also on Brightspace, under Content-&gt;Homework 1. Unzip it into the place you are completing Homework 1, Section 1. </p> <p>This code will output a simple greyscale image that is a gradient that goes from left to right. Nothing special.</p> <p>It also contains the images you will read in and use for the parts that require inputs.</p>"},{"location":"homework/1_c_review/#overview","title":"Overview","text":"<p>Using the starting point as a going off point you are to create a C project with two main files for this section: 1. <code>black_and_white.c</code> - Function declarations for each problem without them being used 2. <code>main.c</code> - Using all of the aforementioned functions to generate all images in the current directory with correct names     1. Should <code>#include \"black_and_white.c\"</code></p> <p>All generated images are to be saved as <code>.pgm</code> files in this section.</p>"},{"location":"homework/1_c_review/#task-1-random-noise-generator-15-points","title":"Task 1: Random Noise Generator (15 points)","text":"<p>Create a function that generates random noise images in both black &amp; white and greyscale</p> <p>Function signature:</p> <pre><code>void generate_random_noise_bw(const char* filename, int width, int height);\nvoid generate_random_noise_grey(const char* filename, int width, int height);\n</code></pre> <p>Requirements:</p> <ul> <li>Use <code>rand()</code> to generate random pixel values</li> <li>For black &amp; white: each pixel should be randomly 0 or 1<ul> <li>This means that the max value must be set at 1</li> </ul> </li> <li>For greyscale: each pixel should be a random value between 0-255</li> <li>Write in binary format (P5)</li> <li>Both images should be 256x256 pixels</li> </ul> <p>Hints:</p> <ul> <li>Use <code>rand() % 2</code> for binary values</li> <li>Use <code>rand() % 0xFF</code> for greyscale values</li> <li>Remember to seed the random number generator with <code>srand(time(NULL))</code> in main</li> </ul>"},{"location":"homework/1_c_review/#task-2-bit-plane-extraction-20-points","title":"Task 2: Bit-Plane Extraction (20 points)","text":"<p>Create a function that extracts individual bit planes from a greyscale image.</p> <p>Function signature:</p> <pre><code>void extract_bit_plane(const char* input_file, const char* output_file, int bit_position);\n</code></pre> <p>Requirements:</p> <ul> <li>Read a PGM image</li> <li>Extract the specified bit plane (0-7, where 0 is LSB and 7 is MSB)</li> <li>Create a new PGM where pixels are either 0 or 255 based on that bit</li> <li>Use bitwise AND operation to check if a bit is set</li> <li>Must use binary/hex number representation (0b...)(0x...)</li> </ul> <p>Example: If a pixel value is <code>0b10110101</code> (181):</p> <ul> <li>Bit plane 0 (LSB): 1 \u2192 output 255</li> <li>Bit plane 4: 0 \u2192 output 0</li> <li>Bit plane 7 (MSB): 1 \u2192 output 255</li> </ul>"},{"location":"homework/1_c_review/#task-3-bitwise-pattern-generation-25-points","title":"Task 3: Bitwise Pattern Generation (25 points)","text":"<p>Create functions that generate images using bitwise operations on pixel coordinates.</p> <p>Function signatures:</p> <pre><code>void generate_xor_pattern(const char* filename, int width, int height);\nvoid generate_and_pattern(const char* filename, int width, int height);\nvoid generate_or_pattern(const char* filename, int width, int height);\n</code></pre> <p>Requirements:</p> <ul> <li>For each pixel at position (x, y), calculate the pixel value using:<ul> <li>x XOR y</li> <li>x AND y</li> <li>x OR y</li> </ul> </li> <li>All operations must use binary operators and hex notation </li> <li>Generate 256x256 images</li> <li>Output as PGM files</li> </ul> <p>Hints:</p> <ul> <li>These operations create interesting geometric patterns</li> <li>The XOR pattern is particularly famous for creating diagonal lines</li> </ul>"},{"location":"homework/1_c_review/#section-1-grading-rubric","title":"Section 1 Grading Rubric","text":"<ul> <li>Task 1: Random noise generation (15 points)</li> <li>Task 2: Bit-plane extraction (20 points)</li> <li>Task 3: Bitwise patterns (25 points)</li> <li>Code style and comments (10 points)</li> <li>Proper binary/hex notation usage (10 points)</li> <li>Memory management (10 points)</li> <li>Proper file I/O (10 points)</li> <li>Total: 100 points</li> </ul>"},{"location":"homework/1_c_review/#section-2-color-images","title":"Section 2: Color Images","text":""},{"location":"homework/1_c_review/#overview_1","title":"Overview","text":"<p>Now you'll work with PPM (color) images. Each pixel has three color channels: Red, Green, and Blue, each ranging from 0-255.</p> <p>This calls for the <code>P6</code> magic number.</p> <p>In the section folder, create a new file <code>color_images.c</code> with the following functions and use them in <code>main.c</code> the same as the previous.</p>"},{"location":"homework/1_c_review/#task-1-color-random-noise-15-points","title":"Task 1: Color Random Noise (15 points)","text":"<p>Create a function that generates random color noise.</p> <p>Function signature:</p> <pre><code>void generate_random_noise_color(const char* filename, int width, int height);\n</code></pre> <p>Requirements:</p> <ul> <li>Generate 256x256 image</li> <li>Each color channel (R, G, B) should be random (0-255)</li> <li>Write in binary format (P6)</li> <li>Must write RGB values sequentially for each pixel</li> </ul>"},{"location":"homework/1_c_review/#task-2-color-bitwise-patterns-20-points","title":"Task 2: Color Bitwise Patterns (20 points)","text":"<p>Create functions that generate color patterns using bitwise operations.</p> <p>Function signatures:</p> <pre><code>void generate_rgb_pattern_1(const char* filename, int width, int height);\nvoid generate_rgb_pattern_2(const char* filename, int width, int height);\nvoid generate_rgb_pattern_3(const char* filename, int width, int height);\n</code></pre> <p>Requirements:</p> <ul> <li>Create three DIFFERENT color pattern generators</li> <li>Each function must generate a 256x256 PPM image</li> <li>Each color channel (R, G, B) must be calculated using a DIFFERENT combination of:<ul> <li>The pixel's x-coordinate</li> <li>The pixel's y-coordinate</li> <li>At least TWO different bitwise operations per pattern</li> </ul> </li> <li>You must use at least 4 of these bitwise operations across all three patterns:<ul> <li>XOR (<code>^</code>)</li> <li>AND (<code>&amp;</code>)</li> <li>OR (<code>|</code>)</li> <li>Left shift (<code>&lt;&lt;</code>)</li> <li>Right shift (<code>&gt;&gt;</code>)</li> <li>NOT (<code>~</code>)</li> </ul> </li> <li>Each channel's formula must produce values in the range 0-255</li> <li>You may NOT use the same formula for all three channels in a single pattern</li> <li>All numeric constants must be in hexadecimal (0x...) or binary (0b...) notation</li> </ul> <p>Examples of valid operations:</p> <pre><code>// Using coordinates with bitwise ops\nR = (x ^ y) &amp; 0xFF;           // XOR coordinates, mask to byte\nG = ((x &lt;&lt; 2) | y) &amp; 0xFF;    // Shift and OR\nB = (~(x &amp; y)) &amp; 0xFF;        // AND then invert\n</code></pre> <p>Grading:</p> <ul> <li>Pattern 1: Uses at least 2 different bitwise operators (7 points)</li> <li>Pattern 2: Uses at least 2 different bitwise operators, different from pattern 1 (7 points)</li> <li>Pattern 3: Most creative/interesting pattern (6 points)</li> </ul> <p>Hints:</p> <ul> <li>Start by experimenting with simple combinations</li> <li>The <code>&amp; 0xFF</code> operation ensures your result stays in 0-255 range</li> <li>Different shift amounts create different visual effects</li> <li>Combining operators (like <code>(x ^ y) &amp; (x | y)</code>) creates complex patterns</li> <li>View your images to see if they're interesting before submitting!</li> </ul>"},{"location":"homework/1_c_review/#task-3-bit-plane-color-extraction-20-points","title":"Task 3: Bit-Plane Color Extraction (20 points)","text":"<p>Extract bit planes from color images for each channel separately.</p> <p>Function signature:</p> <pre><code>void extract_color_bit_plane(const char* input_file, const char* output_file, \n                             char channel, int bit_position);\n</code></pre> <p>Requirements:</p> <ul> <li><code>channel</code> parameter: 'R', 'G', or 'B'</li> <li>Extract specified bit plane from chosen channel</li> <li>Output a greyscale PGM showing that bit plane</li> <li>Other channels' bits should be ignored</li> </ul> <p>For this ones implementation, show each channel in a different image.</p>"},{"location":"homework/1_c_review/#task-4-channel-fragmentation-and-mixing-25-points","title":"Task 4: Channel Fragmentation and Mixing (25 points)","text":"<p>Create functions to separate and recombine color channels.</p> <p>Function signatures:</p> <pre><code>void separate_channels(const char* input_file, const char* r_out, \n                       const char* g_out, const char* b_out);\nvoid mix_channels(const char* input_file_a, const char* input_file_b, \n                    const char* output_file);\n</code></pre> <p>Requirements:</p> <ul> <li><code>separate_channels</code>: Create three color images, for each color channel, where all other color channels are removed</li> <li><code>mix_channels</code>: Take two images and xor their color channels together</li> </ul>"},{"location":"homework/1_c_review/#section-2-grading-rubric","title":"Section 2 Grading Rubric","text":"<ul> <li>Task 1: Color random noise (15 points)</li> <li>Task 2: Color bitwise patterns (20 points)</li> <li>Task 3: Color bit-plane extraction (20 points)</li> <li>Task 4: Channel operations (25 points)</li> <li>Code style and comments (10 points)</li> <li>Proper binary/hex notation (10 points)</li> <li>Total: 100 points</li> </ul>"},{"location":"homework/1_c_review/#submission-guidelines","title":"Submission Guidelines","text":""},{"location":"homework/1_c_review/#what-to-submit","title":"What to Submit","text":""},{"location":"homework/1_c_review/#section-1-in-folder-named-section1","title":"Section 1 (in folder named <code>section1/</code>):","text":"<ul> <li><code>black_and_white.c</code> - Your function implementations</li> <li><code>main.c</code> - Driver program that calls all functions</li> <li>All generated <code>.pgm</code> files from your program</li> </ul>"},{"location":"homework/1_c_review/#section-2-in-folder-named-section2","title":"Section 2 (in folder named <code>section2/</code>):","text":"<ul> <li><code>color_images.c</code> - Your function implementations</li> <li><code>main.c</code> - Driver program that calls all functions (can include black_and_white.c if you want both sections in one main)</li> <li>All generated <code>.ppm</code> and <code>.pgm</code> files from your program</li> </ul>"},{"location":"homework/gcc_install/","title":"Installation Process","text":""},{"location":"homework/gcc_install/#gcc-install","title":"GCC Install","text":"<p>GCC or the GNU Compiler Collection is an open source collection of programming tools for lower-level languages like C, C++, FORTRAN, and Assembly. We will be using it to compile and run the programs for demos and homeworks using it.</p>"},{"location":"homework/gcc_install/#windows","title":"Windows","text":"<p>There are many methods to install gcc on Windows-based system, each attempting to stream-line some part of the process. We will be using WinLibs GCC pre-compiled version of the collection and manually adding it to the PATH so that you may use the programs in Windows CMD.</p> <ol> <li>Go to https://winlibs.com/:    </li> <li>Scroll down to the Download section:    </li> <li>Click on the red-circled \"Download it here\" to download the latest release for Windows 64-bit systems. If you need the 32-bit version for some reason, it is below. All modern computers are 64-bit so you should be fine with that.</li> <li>That will download a zip file inside of your \"Downloads\" folder:    </li> <li>Right click on the file and select \"Extract All\", or use the top tools to select the same option as in the image:    </li> <li>That will open up a new dialog box asking where to extract the file contents to, click \"Browse\":    </li> <li> <p>Using the File Explorer's side bar menu, scroll down to find \"This PC-&gt;C:\", click it, then press the \"Select Folder\" button, as indicated:    </p> </li> <li> <p>Click \"Extract\", and wait for the process to complete:</p> </li> <li> <p>The compiler is now installed, however your windows Command Prompt cannot use the compiler and other tools until their locations have been added to the PATH. Click the search bar on the task bar and search for  \"environment variables\", click on the \"Edit the system environment variables\" option:    </p> </li> <li>Click on the \"Environment Variables...\" button:     </li> <li>With the new menu that pops up, click on the \"Path\" option under \"System variables\", NOT the one that is for your account. With that selected click on the \"Edit...\" button:     </li> <li>In the new window, click \"New\" to add a new line to the PATH, then click \"Browse...\":     </li> <li>With the new file explorer open, go to \"This PC-&gt;Local Disk (C:)-&gt;mingw64-&gt;bin\", with \"bin\" as the selected folder:     </li> <li>Click \"OK\"</li> <li>Click \"OK\"</li> <li>Click \"OK\"</li> <li>Click \"OK\"</li> <li>GCC has now been installed on your Windows computer! To test this, search cmd in the search bar to open the command prompt</li> <li>Type <code>gcc</code>, and press enter</li> <li>This should result in the following error:     </li> <li>If something else happens, try the process again pay sure to follow the instructions and that you are always downloading and installing into local directories and not those on \"OneDrive\" or other such networked drives</li> <li>If you continue to struggle, bring it up in class, or email me</li> </ol>"},{"location":"homework/gcc_install/#mac","title":"Mac","text":"<p>Apple products have their own suite of gcc tools installed by default, but to be sure that you have full access to them, we will be installing the GNU versions via Homebrew.</p> <ol> <li>Go to https://brew.sh/</li> <li>Follow the instructions there to install brew. It should be<ol> <li>Open macOS terminal</li> <li>Copy-Paste the command below    <code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"</code></li> <li>Run and let it do its thing</li> </ol> </li> <li>With that installed, keep the terminal open and type: <code>brew install gcc</code></li> <li>And you are all done, you should now have access to the gcc command</li> <li>You may test it similarly to the Windows test above, when run without any files given it should produce an error that says \"no input files\". If it says command not found, something is wrong and contact me.</li> </ol>"},{"location":"homework/gcc_install/#linux","title":"Linux","text":"<p>Usually during the installation process you install gcc and the other build tools as a consequence. If not just use your native package manager and install gcc.</p>"},{"location":"homework/gcc_install/#text-editor-or-ide-install","title":"Text Editor or IDE Install","text":"<p>There is no required text editor for this course, however for nearly all of the in-class demos I will be using Sublime Text as my primary text editor. </p> <p>Integrated development environments or IDEs are a little too high-level for courses and remove some of the learning process for students. They also may end up becoming topics to learn in themselves. So, while there is no hard ban on students using tools like VScode or other powerful coding platforms, I strongly suggest the use of simple text editors like Sublime Text.</p> <p>To install Sublime Text, go to https://www.sublimetext.com/ and it will have a specialized installation process for your system on the website. Just click the button that says \"Download for (YOUR SYSTEM)\", and follow the instuctions.</p>"},{"location":"homework/how_to_hand_in/","title":"How To Hand In","text":"<p>During this semester we will have different kinds of assignments meant to aid in understanding, test your skills, and prepare you for the later examinations.</p>"},{"location":"homework/how_to_hand_in/#format-of-submissions","title":"Format of Submissions","text":"<p>Depending on the format of the assignment, you may be asked to produce different types of artifacts to accomplish the given problem set, sometimes multiple different kinds in a single set. </p> <p>Some of the most common type of problems in the HWs will be, along with the general guidelines of how they should be presented:</p> <ul> <li>Coding Problems - Problems that require the generation of source code that meets all requirements of the HW specification<ul> <li>Hand this in as the source code files with the intended programming language file extension</li> <li>Unless told specifically, DO NOT include executables or binaries made for YOUR system. Only hand in source code</li> </ul> </li> <li>Written Problems - These will have you generating natural language responses for a given prompt, length varying and specified in each problem<ul> <li>These can be handed in the following file types:<ul> <li>.txt, .md, .pdf, .docx</li> </ul> </li> <li>If you intend to hand-write answers, you may, however write legibly and scan your answers in one of the following types<ul> <li>.pdf, .png, .jpg</li> </ul> </li> </ul> </li> <li>Drawing Problems - At times I will ask for images to be generated by you as assignments, these can be completed by hand, on tablets, or using some drawing software<ul> <li>Hand these in similarly to the above, in fact at times written and drawing problems may be in a single section</li> </ul> </li> </ul>"},{"location":"homework/how_to_hand_in/#organization-of-files","title":"Organization of Files","text":"<p>Many assignments will contain multiple parts or sections in each, requiring the creation of multiple files in the same and different file types. To keep everything organized with how I am expecting the submissions we will be following the structure below:</p> <ul> <li>Each completed homework should be submitted as a single .zip file that contains:<ul> <li>A folder for each section of homework containing:<ul> <li>All generated files from that section in appropriate file types as listed above</li> </ul> </li> </ul> </li> </ul> <p>For example, if there was the following homework:</p> <ul> <li>Homework 0: Fake Homework<ul> <li>Section 1: Do some code<ul> <li>Code 1</li> <li>Code 2</li> </ul> </li> <li>Section 2: Do some writing<ul> <li>Questions</li> </ul> </li> <li>Section 3: Do some drawing<ul> <li>Questions</li> </ul> </li> </ul> </li> </ul> <p>The file structure should look like this: <pre><code>CS240-HW0-LastNamezip\n\u251c\u2500\u2500 Section1/\n\u2502   \u251c\u2500\u2500 code1.c\n\u2502   \u2514\u2500\u2500 code2.c\n\u251c\u2500\u2500 Section2/\n\u2502   \u2514\u2500\u2500 answers.txt\n\u2514\u2500\u2500 Section3/\n    \u2514\u2500\u2500 drawings.png\n</code></pre></p> <p>If you noticed, I also have an intended naming scheme. Name the overall .zip submission in the form \"CS240-HW{HW number}-{Student Last Name}.zip\". Each section and file will be specified individually for each assignment, be sure to pay attention to it.</p>"},{"location":"homework/how_to_hand_in/#where-to-hand-in","title":"Where to hand in","text":"<p>While the course material and the homework problems are posted here, on this website, all submissions of assignments will be done on the SUNY Poly's Brightspace system. This will also be where all of your grades for assignments and quizzes will be located. This is to ensure grades are in a single place as well as utilize Brightspace's submission system.</p> <p>I will show this off in class and generate images of the process at a later date, however most if not all other courses at SUNY Poly use Brightspace, so I am sure you are acquainted  with it. </p>"},{"location":"labs/c_compilation/","title":"C Compilation Objects","text":"<p>To go from human-readable C code to a running program on a computer requires a few steps of processing before being converted to the machine code that ultimately is what the computer runs on the CPU. </p> <p>This lab will use a few <code>gcc</code> command flags to extract our those intermediate forms of the program we made. To reiterate the compilation process in the C review lesson, there are four main steps in C compilation: 1. Preprocessing: The C preprocessor (CPP) formats the source code using macros like <code>#include</code> or <code>#define</code>, including needed headers and applying any user-defined changes before passing to the next step 2. Compilation: The compiler translates C source code into assembly language 3. Assembly: The assembler then converts the assembly code into machine code, producing object files, <code>.o</code> or <code>.obj</code>, as a result 4. Linking: The linker orders the object files properly and combines them into a single executable program that is ready to run on the target system</p> <p>Each one of these steps produces distinct products that we can look closer at to understand the process a bit more. In order to do that, we will need another tool to be added to our system PATHs. <code>xxd</code> is a </p>"},{"location":"lessons/1_introduction/","title":"Introduction","text":"<p>Welcome to CS 220 - Computer Organization! This lesson's purpose is to set the stage and better understand what information will be covered in the course. Computer Organization is a broad topic with many possible deep wells to fall into. In this course, we will attempt to cover a big picture view into how computers work at multiple levels of abstraction, exploring the many facets that each has. Here we introduce:</p> <ul> <li>Computers</li> <li>Turing Machines</li> <li>The Abstraction Hierarchy</li> <li>Von Neumann Model</li> <li>Programming Language Abstraction</li> </ul>"},{"location":"lessons/1_introduction/#computers","title":"Computers","text":"<p>Computers have infiltrated every part of our lives either indirectly or directly for some time now. They sit at the core of every financial transaction, recreational activity, and many social relationships that most human beings experience for the last 20 years. Because of this and the choices that led you to CS, it is highly important to understand computers on a deep level for both career success and for designing a better future.</p> <p>The word computer has historically taken on different meanings, however at its most basic is \"a thing that computes\". The first named computers were human, people who would sit at desks and do repeated numerical calculations for businesses and institutions. The first object to fit the definition \"a thing that computes\" goes very far back, as far back as the first recorded civilizations. </p> <p>Evidence of Sumerian abacuses has been dated between 2700 and 2300\u00a0BC, with other examples of clay tablets used to aid in mathematical calculations. </p> <p></p> <p>However, in the modern day, when one says \"computer\" we do not think about times tables and abacuses, we are talking about digital computers (as opposed to the previous analog computers). </p>"},{"location":"lessons/1_introduction/#analog-and-digital-computers","title":"Analog and Digital Computers","text":"<p>Analog computers are devices that model predetermined calculations through the use of voltage, gears, pulleys, or other phenomenon that is related to the calculation in question. Examples include:</p> <ul> <li>Sphere-based tidal predictions (Link)</li> <li>The Antikythera Mechanism (Link)</li> <li>Slide Rulers (Link)</li> <li>Mechanical Calculators (Link) </li> </ul> <p>These computers are:</p> <ul> <li>Purpose built - they cannot be reprogrammed and must have their purpose defined beforehand</li> <li>No memory - they do not store memory or act on some bank of stored information that is able to be rewritten</li> <li>Difficult to use - since their design and purpose are so tied, often they were unintuitive to use to the uninitiated, also there were no commonalities between two different analog computers  </li> </ul> <p>Digital computers are the modern devices that use discrete numbers to symbolically represent information and does operations on that data using a finite set of general operations. Today, they are made of transistors, small electrical components that can either block or allow pass a electrical signal depending on whether itself is being fed an electrical signal. These transistors are used to make logic gates that are copied and repeated billions of times to form the modern idea of a computer. These computers are:</p> <ul> <li>General Purpose - they can be made general and can complete any computation task</li> <li>Possess Writable Memory - by having a store of memory it can store programs that change its behavior and store intermediate information</li> <li>Expandable - Interfaces can be developed over time to make working with the computer easier, programs can be rewritten to fix mistakes. Overall, it is easy to use.</li> </ul>"},{"location":"lessons/1_introduction/#turing-machines","title":"Turing Machines","text":"<p>The modern idea of a general-purpose computer or \"Universal Computing Machine\" was developed by Alan Turing in 1936 with his paper On Computable Numbers. There he proposed such a machine, referred today as a \"universal Turing Machine\", and proved that it was capable of computing anything that is computable by executing instructions stored in memory. Although theoretical in nature, we use the idea of a Turing machine to see if a device meets the criteria of being able to compute anything that is computable; if it is Turing-complete.  </p> <p></p> <p>Any machine can be called Turing-complete so long as it is able to:</p> <ul> <li>Read and write data to memory</li> <li>Perform conditional branching</li> <li>Loop or repeat operations</li> <li>The possibility of having infinite memory<ul> <li>This means that the fundamental mechanism is not limited in its access in memory. Even though infinite memory is physically impossible, we can expand to allow for it to be approached</li> </ul> </li> </ul> <p>So long as a device can do the above and simulate a Turing machine, it is Turing-complete, regardless of what it is made out of, or how it accomplishes the above. Modern digital computers use transistors and boolean logic to build up to a general computing system. </p>"},{"location":"lessons/1_introduction/#transistors-to-desktops","title":"Transistors to Desktops","text":"<p>The conceptual journey of understanding how we are able to do anything with enough transistors will be a central theme to the course.  To demonstrate the overall, big-picture view of a computer and working at these different conceptual layers, computer scientists often use layered abstraction diagrams to organize the many logical structures that build on top of one another.</p> <p></p> <p>In this Abstraction Hierarchy, we can see that working at the application layer is most abstract from what is actually happening at the physical level. Rarely do we ever need to worry about overflowing a memory register when playing Minecraft or Word. Most of the time, as programmers, we work within the \"Programming Language\" and \"Algorithm\" layers, since this is where software development takes place. However, in order to interact with the computer in such a way there are a lot of steps that need to happen before we get to use <code>printf()</code>. </p> <p>At the bottom of the hierarchy is \"Electronics and Physics\", these are the natural laws that we harness to represent information. If it was not for the way that electricity flows through wires and our intelligent manipulation of it, the modern computer would not exist. Electricity is not the only method of representing computation, in fact we are trying to find new ways of accomplishing computation:</p> <ul> <li>Quantum Computers - Using quantum particles to represent computation</li> <li>Optical Computing - A growing research field in unconventional computation methods is using light to store and operate on data</li> <li>DNA Computing - The very programming language our body runs on can be harnessed to run many repeated operations in a fraction of the time it takes for electronic based computers, although very specialized and very difficult to read the results at the end</li> </ul> <p>The main way we channel electricity to compute is by use of transistors and other electronics components. Transistors are essentially electrical switches that are themselves controlled by an electric signal. They function like this:</p> <p></p> <p>Transistors have two states, on and off, giving the smallest unit of information, a bit. On and off map directly to True and False, allowing a critical connection to boolean algebra and enabling the construction of logic gates. These logic gates are a bridge that facilitate building more complex systems from the natural phenomenon of electricity. These logic gates are used to build systems that allow for arithmetic to be done using binary numbers, store memory, and control other parts of the computers architecture. Each one of these components are organized according to a computer architecture to form the central processing unit (CPU). The main architecture used for modern computers is the Von Neumann Architecture or Model.</p>"},{"location":"lessons/1_introduction/#von-neumann-architecture","title":"Von Neumann Architecture","text":"<p>The Von Neumann architecture falls at the \"Micro Architecture\" layer on our abstraction hierarchy and organizes the logic gates into components with concrete purposes to build a general computing platform. The components are:</p> <ul> <li>The Central Processing Unit (CPU) - The main computational workhorse, here the CPU reads machine instructions and executes them. It is made of two parts:<ul> <li>Control Unit - Used to sequence operations to be performed by the machine, orchestrating the other components</li> <li>Arithmetic/Logic Unit - Used to perform the instructions from the control unit on the memory unit</li> </ul> </li> <li>Memory Unit - A bank of memory that stores both instructions and data in the same address space</li> <li>Input Device - The source of information into the CPU, can be new instructions or data</li> <li>Output Device - Receives information from the CPU and routes it to other devices for control signals</li> </ul>"},{"location":"lessons/1_introduction/#programming-language-abstraction","title":"Programming Language Abstraction","text":"<p>While the Micro Architecture defines how instructions map operations done on memory, the Instruction Set Architecture (ISA) defines what instructions there are in the first place. These instructions are what the CPU will execute at the end of the day and is called machine code. Each individual instruction must be carefully picked and designed to be as fundamental as possible so that further functionalities can be built on top of them without later alteration. The two most popular instruction set architectures that you may know are:</p> <ul> <li>Intel's x86-64 instruction set - The current industry standard instruction set for most consumer PCs. Originally designed to only handle 32-bit length numbers (x86), but was later updated to support 64-bit numbers (x86-64). Owned by Intel, must pay them to create chips with it.</li> <li>RISC-V (\"risk-five\") - Reduced, optimized instruction set that sees use for environments where computational resources are constrained. Less widely used, but recently has seen more adoption. Open-sourced.</li> </ul> <p>This machine code is stored and read by the CPU in raw binary in order to be \"understood\". However, writing programs in raw binary is nearly impossible for a human to do in a reasonable amount of time. To make direct communication with the CPU easier, each machine code instruction was given an identifier written in characters that related to it purpose and a system of writing these more human-readable instructions into programs was developed, resulting in the creation of the Assembly Language.</p> <p></p> <p>Assembly language made it easier to develop programs, however the instructions were now no longer in a form that the CPU could understand. The CPU directly read instructions as binary codes, and as a result all instructions that intend to be ran must be in that form. This necessitated the creation of the assembler, a program that can convert assembly code into binary machine code. </p> <p>This idea of creating a level of representation on top of what you are actually doing on the computer for ease of use and development is yet another example of abstraction and working up the hierarchy. Every level above builds on top of assembly in some way, making it the lowest level of abstraction we as programmers can interact with normally. This puts it in a special place, an eventuality that every language designer and chip manufacturer should respect. As a result of this importance, it will be one of the focuses of this course and will be programmed in by the end of the semester.</p> <p>From assembly we build all other programming languages, for the purposes of this course we will focus on the C programming language primarily. This is due to the fact that C preserves certain low-level access that other languages hide away. C allows for direct memory access and its compilations object that are in assembly and machine code as easy to access. The next lesson will review programming in the C language and there will be a lab exploring these intermediate representations of your C programs.</p>"},{"location":"lessons/1_introduction/#optional-questions","title":"Optional Questions","text":"<ol> <li>You may have heard of \"Moore's Law\", if not look it up. Roughly describe it and, in your own words, indicate if you think the trend it identifies will continue or not. Justify your answer with why you think that or how you predict it will happen.</li> <li>In C, after you compile and run, you will get a <code>a.exe</code> or <code>a.out</code> file that actually runs your program. What level of the abstraction hierarchy do you think that is working in?</li> <li>With what you know about C, can you identify the parts of C that make it Turing-complete? From the criteria of being Turing-complete, can you think of how it is implemented in C?</li> </ol>"},{"location":"lessons/2_reviewing_c/","title":"C Review","text":"<ul> <li>A general C review</li> <li>Compiled languages</li> <li>C datatypes, both primitive and composite</li> <li>Conditionals and loops</li> <li>The C Pre-Processor</li> <li>and introducing C++</li> </ul>"},{"location":"lessons/2_reviewing_c/#compilation","title":"Compilation","text":"<p>Before recalling the C syntax and semantics, we must first remember the domain we are working in and how programs are ran on a computer system. Computers cannot understand human languages without the power and water supply of a medium-sized town, meaning there must be intermediate steps to running our human-readable code on a computer.</p>"},{"location":"lessons/2_reviewing_c/#compilation-and-interpretation","title":"Compilation and Interpretation","text":"<p>The two main methods of getting a computer to run code are compilation and interpretation. </p> <p>Interpreted languages like Python and JavaScript are executed line-by-line by an interpreter at runtime. When you run a Python script, the interpreter reads each line, translates it to machine instructions, and executes it immediately. This makes development faster since you can test code quickly, but execution tends to be slower since the machine instructions are not always written in the most efficient manner out-of-the-box.</p> <p>Compiled languages, like C and C++, accomplish this task in a different way. Instead of being executed by and interpreter at runtime, C programs are compiled and converted to low-level machine code before runtime. Essentially, compiled languages are translated into machine code at compile time for the target system to produce an executable that can be ran without recompilation or interpretation. This leads to faster programs and more fine-grained control over what happens during the course of your program</p> <p>This process involves four primary steps:</p> <ol> <li>Preprocessing: The C preprocessor (CPP) formats the source code using macros like <code>#include</code> or <code>#define</code>, applying any user-defined changes before passing to the next step</li> <li>Compilation: The compiler translates C source code into assembly language</li> <li>Assembly: The assembler then converts the assembly code into machine code, producing object files, <code>.o</code> or <code>.obj</code>, as a result</li> <li>Linking: The linker orders the object files properly and combines them into a single executable program that is ready to run on the target system</li> </ol> <p>The following are the commands to compile a simple C program, using the GNU C Compiler: <pre><code># Compile source.c into an executable named program\ngcc source.c -o program\n# Run the executable\n./program\n</code></pre> In this simple program, all of the main steps are hidden from the user, however we can use compiler flags to view some of the intermediate files:</p> <ul> <li><code>-E</code>: Stops after preprocessing stage</li> <li><code>-S</code>: Stops compilation after generating assembly code</li> <li><code>-c</code>: Stops compilation after generating object files, preventing linking</li> </ul>"},{"location":"lessons/2_reviewing_c/#basics","title":"Basics","text":"<p>Now that we have reviewed how to compile and run our programs, let's go over the the fundamental building blocks of C programming.</p> <p>The following is a standard \"Hello World!\" program written in C: <pre><code>#include &lt;stdio.h&gt;\n\nint main(int argc, const char* argv[])\n{\n    printf(\"Hello CS240!\\n\");\n\n    return 0;\n}\n</code></pre></p> <ol> <li><code>#include &lt;stdio.h&gt;</code> - This is a preprocessor macro to include the <code>stdio.h</code> file at the beginning of this source code file.</li> <li><code>int main(){}</code> - The main function, our main entry point into executing code on the computer. The compiler runs this function in the final executable, making it responsible for orchestrating  all other functions.</li> <li><code>(int argc, const char* argv[])</code> - Command line arguments. When you run the program in the command-line, you may optionally give additional parameters to feed into your program, for example: <code>./program argument1 argument2</code>. <code>argc</code> and <code>argv</code> are variables that contain information about the command-line arguments. <code>argc</code><ol> <li><code>argc</code> - the number of arguments, including the filename of the executable<ol> <li>In the example above, it would take on the value 3</li> </ol> </li> <li><code>argv</code> - an array of char*'s to the actual string parameters passed</li> </ol> </li> <li><code>printf(\"Hello CS240!\\n\");</code> - This line represents a statement in C, an individual line of code. All statements in C must end in a semicolon <code>;</code>. This specific statement is calling a function from <code>stdio.h</code>, <code>printf();</code> which allows the programmer to print information to the screen.</li> <li><code>return 0;</code> - The return statement. When we defined <code>main();</code>, we put an <code>int</code> identifier before the function identifier. This defines the return type that is expected from our function, which is enforced by the compiler. When the return statement is ran the function ends and as will the entire program.  </li> </ol>"},{"location":"lessons/2_reviewing_c/#variables-and-data-types","title":"Variables and Data Types","text":"<p>Variables in C must be declared with a specific type before use. Unlike dynamically typed languages, C requires you to explicitly state what kind of data each variable will hold.</p> <p>The following is an example of declaring variables: <pre><code>#include &lt;stdio.h&gt;\n\nint main(int argc, const char* argv[])\n{\n    int num_books = 1000;      // Declaring an int type with a starting value\n    float average_length;      // Declaring a float type without a starting value\n\n\n    return 0;\n}\n</code></pre></p>"},{"location":"lessons/2_reviewing_c/#basic-data-types","title":"Basic Data Types","text":"<p>C provides several primitive data types:</p> <ul> <li>Integer Types: <code>int</code>, <code>short</code>, <code>long</code>, <code>long long</code><ul> <li>Typically <code>int</code> is 4 bytes (32 bits), ranging from -2,147,483,648 to 2,147,483,647</li> <li>Can be modified with <code>unsigned</code> for non-negative values only</li> </ul> </li> <li>Floating-Point Types: <code>float</code>, <code>double</code><ul> <li><code>float</code> is single-precision (4 bytes)</li> <li><code>double</code> is double-precision (8 bytes), preferred for most applications</li> </ul> </li> <li>Character Type: <code>char</code><ul> <li>1 byte, used for characters and small integers</li> <li>Characters are enclosed in single quotes: <code>'A'</code>, <code>'z'</code>, <code>'\\n'</code></li> </ul> </li> <li>Boolean Type: <code>bool</code> with <code>&lt;stdbool.h&gt;</code><ul> <li>Values are <code>true</code> or <code>false</code> Example declarations: <pre><code>int count = 0;\ndouble pi = 3.14159;\nchar grade = 'A';\nunsigned int positive_only = 42;\n</code></pre></li> </ul> </li> </ul>"},{"location":"lessons/2_reviewing_c/#composite-data-types","title":"Composite Data Types","text":"<p>Beyond basic types, C allows you to build more complex data structures:</p> <p>Arrays: Contiguous blocks of memory holding multiple elements of the same type <pre><code>int numbers[5] = {10, 20, 30, 40, 50};\nchar name[20] = \"Alice\";  // Strings are char arrays\n\n// Access elements by index (zero-indexed)\nint first = numbers[0];  // 10\nnumbers[2] = 35;         // Modify third element\n</code></pre> Arrays in C have fixed size and no bounds checking. Accessing an index outside the array's bounds leads to undefined behavior, a common source of bugs.</p> <p>Structures: Group related data of different types <pre><code>struct Student {\n    char name[50];\n    int id;\n    double gpa;\n};\n\nstruct Student alice;\nalice.id = 12345;\nalice.gpa = 3.8;\nstrcpy(alice.name, \"Alice Johnson\");\n</code></pre></p> <p>Pointers: Variables that store memory addresses <pre><code>int value = 42;\nint *ptr = &amp;value;  // ptr stores the address of value\n\nprintf(\"Value: %d\\n\", *ptr);  // Dereference to get value (42)\n*ptr = 100;  // Modify value through pointer\nprintf(\"New value: %d\\n\", value);  // Prints 100\n</code></pre> Pointers are powerful but dangerous. They enable dynamic memory allocation and efficient data manipulation, but incorrect pointer usage causes crashes, memory leaks, and security vulnerabilities.</p>"},{"location":"lessons/2_reviewing_c/#conditionals","title":"Conditionals","text":"<p>Conditionals allow your program to make decisions based on conditions.</p> <p>If-Else Statements <pre><code>int score = 85;\n\nif (score &gt;= 90) {\n    printf(\"Grade: A\\n\");\n} else if (score &gt;= 80) {\n    printf(\"Grade: B\\n\");\n} else if (score &gt;= 70) {\n    printf(\"Grade: C\\n\");\n} else {\n    printf(\"Grade: F\\n\");\n}\n</code></pre></p> <p>Switch Statements: Useful for multiple discrete cases <pre><code>char operation = '+';\nint a = 10, b = 5;\n\nswitch (operation) {\n    case '+':\n        printf(\"Result: %d\\n\", a + b);\n        break;\n    case '-':\n        printf(\"Result: %d\\n\", a - b);\n        break;\n    case '*':\n        printf(\"Result: %d\\n\", a * b);\n        break;\n    default:\n        printf(\"Unknown operation\\n\");\n}\n</code></pre> The <code>break</code> statement is crucial in switch cases to prevent fall-through to subsequent cases.</p>"},{"location":"lessons/2_reviewing_c/#loops","title":"Loops","text":"<p>Loops enable repetition of code blocks.</p> <p>For Loops: Best when the number of iterations is known <pre><code>// Print numbers 0 through 9\nfor (int i = 0; i &lt; 10; i++) {\n    printf(\"%d \", i);\n}\n\n// Iterate through an array\nint arr[5] = {2, 4, 6, 8, 10};\nfor (int i = 0; i &lt; 5; i++) {\n    printf(\"%d \", arr[i]);\n}\n</code></pre></p> <p>While Loops: Best when the number of iterations is unknown <pre><code>int count = 0;\nwhile (count &lt; 5) {\n    printf(\"Count: %d\\n\", count);\n    count++;\n}\n</code></pre></p> <p>Do-While Loops: Execute at least once, then check condition <pre><code>int input;\ndo {\n    printf(\"Enter a positive number: \");\n    scanf(\"%d\", &amp;input);\n} while (input &lt;= 0);\n</code></pre></p>"},{"location":"lessons/2_reviewing_c/#the-c-pre-processor-cpp","title":"The C Pre-Processor (CPP)","text":"<p>The C preprocessor runs before compilation and handles directives that begin with <code>#</code>. These directives modify your source code before it's compiled.</p> <p>Include Directive: Imports header files <pre><code>#include &lt;stdio.h&gt;   // System header (standard library)\n#include \"myheader.h\"  // User-defined header (local file)\n</code></pre></p> <p>Define Directive: Creates macros and constants <pre><code>#define PI 3.14159\n#define MAX_SIZE 100\n#define SQUARE(x) ((x) * (x))\n\n// Usage\ndouble area = PI * SQUARE(radius);\n</code></pre> Macros are simple text replacements. Notice the parentheses in <code>SQUARE(x)</code> to avoid unexpected behavior with operator precedence.</p> <p>Conditional Compilation: Include or exclude code based on conditions <pre><code>#define DEBUG\n\n#ifdef DEBUG\n    printf(\"Debug: x = %d\\n\", x);\n#endif\n\n#ifndef MAX_VALUE\n    #define MAX_VALUE 1000\n#endif\n</code></pre> This is useful for platform-specific code or enabling debug output during development.</p>"}]}