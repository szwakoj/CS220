{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CS220 - Computer Organization","text":"<p>Welcome to CS 220, Spring 2026!</p> <p>This site serves as the main entry point for the course and will be the means of distributing course material. All information on here will be translated to Brightspace for grades, due dates, and handing in assignments.</p> <p>Important links:</p> <ul> <li>Syllabus - Syllabus of the course, containing critical information about the course</li> <li>Schedule - Course schedule; use primarily as a history of topics, launching point, and 1-2 week look ahead</li> <li>Lessons - The main repository of course material, all lectures are based on these</li> <li>Homeworks - This link takes you to the details of how to hand in homework, as well as all currently given assignments</li> <li>Labs - The course's guided labs, optional and initiated in-person, with students finishing at home</li> </ul> <p>Note on Accessibility</p> <p>This course website was adopted and hand tailored to be in-line with new WCAG accessibility guidelines. If there are any issues accessing its material or if there are features not working properly, please reach me at szwakoj@sunypoly.edu with the subject line \"CS 220 Site Issue\".</p> <p>In addition to offering all course material in this format, the source plain text, markdown files are available at this course's github to be viewed through your markdown viewer of choice. </p>"},{"location":"glossary/","title":"Glossary","text":"<p>Quick reference meanings for the course. Note, these are not complete and accepted formal definitions. </p> <p>Computer (historical) - At its most basic, \"a thing that computes\"; originally referred to humans who would sit at desks and do repeated numerical calculations for businesses and institutions.</p> <p>Digital Computer - Modern devices that use discrete numbers to symbolically represent information and perform operations on that data using a finite set of general operations. Made of transistors that form logic gates.</p> <p>Analog Computer - Devices that model predetermined calculations through the use of voltage, gears, pulleys, or other phenomenon that is related to the calculation in question.</p> <p>Purpose Built - A characteristic of analog computers meaning they cannot be reprogrammed and must have their purpose defined beforehand.</p> <p>Transistor - Small electrical components that can either block or allow passage of an electrical signal depending on whether itself is being fed an electrical signal. Used to make logic gates in modern computers.</p> <p>Universal Turing Machine - A theoretical general-purpose computer proposed by Alan Turing in 1936, capable of computing anything that is computable by executing instructions stored in memory.</p> <p>Turing-complete - A device that can simulate a Turing machine by being able to: read and write data to memory, perform conditional branching, loop or repeat operations, and have the possibility of infinite memory.</p> <p>Bit - The smallest unit of information, having two states (on and off) that map directly to True and False, 1 and 0.</p> <p>Logic Gates - Components built from transistors that use boolean algebra; they bridge the gap between natural electrical phenomenon and more complex computing systems.</p> <p>Abstraction Hierarchy - Layered diagrams used by computer scientists to organize the many logical structures that build on top of one another in a computer system, from electronics/physics up to applications.</p> <p>Von Neumann Architecture (Von Neumann Model) - The main architecture used for modern computers, organizing logic gates into components with concrete purposes to build a general computing platform. Falls at the \"Micro Architecture\" layer of the abstraction hierarchy.</p> <p>Central Processing Unit (CPU) - The main computational workhorse that reads machine instructions and executes them. Made of two parts: the Control Unit and Arithmetic/Logic Unit.</p> <p>Control Unit - Part of the CPU used to sequence operations to be performed by the machine, orchestrating the other components.</p> <p>Arithmetic/Logic Unit - Part of the CPU used to perform the instructions from the control unit on the memory unit.</p> <p>Memory Unit - A bank of memory that stores both instructions and data in the same address space.</p> <p>Input Device - The source of information into the CPU, can be new instructions or data.</p> <p>Output Device - Receives information from the CPU and routes it to other devices for control signals.</p> <p>Instruction Set Architecture (ISA) - Defines what instructions exist for the CPU to execute; these instructions are what become machine code.</p> <p>Machine Code - The individual instructions executed by the CPU, stored and read in raw binary.</p> <p>Assembly Language - A system of writing CPU instructions using human-readable identifiers (characters that relate to the instruction's purpose) instead of raw binary, making direct communication with the CPU easier.</p> <p>Assembler - A program that can convert assembly code into binary machine code that the CPU can understand and execute.</p>"},{"location":"schedule/","title":"Schedule","text":""},{"location":"schedule/#disclaimer","title":"DISCLAIMER","text":"<p>This schedule will be primarily used as a history of topics that we have covered thus far, as well as a short look into the future. To best attend to the class' pace, future looks will be limited to 1-2 weeks ahead with all due dates known when assignments are given and quiz/test dates when they are announced. Any changes made to significant dates will be in the students favor, if they happen. </p> Date Topic Lessons Labs Homework 1/19/26 (Week 1) - Syllabus 1/26/26 (Week 2) - Introduction- History Introduction 2/2/26 (Week 3) - C Review- Binary C Review - Homework 1 : C Review (Due 2/27/26) (Released 2/1/26) 2/9/26 (Week 4) - Started Binary- Minor Hiccup 2/16/26(Week 5) - Finish Binary + Hex- Binary Operations Binary"},{"location":"syllabus/","title":"Syllabus","text":""},{"location":"syllabus/#course-computer-organization-cs-220","title":"Course: Computer Organization (CS 220)","text":"<p>Section: 02</p> <p>CRN: 2040</p> <p>Semester: Spring 2026</p> <p>On-Campus, 4 Credits</p> <p>Room: Kunsela Hall A135 </p> <p>Meeting Times: Mondays and Wednesdays, 12:00pm - 1:50pm</p>"},{"location":"syllabus/#office-hours-and-contact-info","title":"Office Hours and Contact Info","text":"<p>Instructor: John Szwakob III (Mr. S)</p> <p>Office Location: Kunsela Hall C127</p> <p>Office Hours: - Mondays 2:00pm - 4:00pm</p> <ul> <li> <p>Tuesdays and Thursdays, 10:00am - 12:00pm</p> </li> <li> <p>Friday by appointment</p> </li> </ul> <p>Phone: (315) 792-7256</p> <p>Note: This is my office phone, I will be in the office guaranteed during the office hours above, however outside of that I may be teaching if you call during school hours. I encourage you to leave a message. The best way to contact me remains through the email below as I can respond much quicker for time sensitive matters.</p> <p>Email: szwakoj@sunypoly.edu</p>"},{"location":"syllabus/#course-catalog-description","title":"Course Catalog Description:","text":"<p>Introduces students to the organization and architecture of computer systems as a hierarchy of levels, beginning with the standard von Neumann model and then moving forward to more recent architectural concepts. Topics include digital logic, microprogramming, conventional machine and assembly language levels. Emphasis is given to those aspects of computer hardware that effect programming. Prerequisite: CS 108</p>"},{"location":"syllabus/#course-objectives","title":"Course Objectives:","text":"<ul> <li>Give a high-level overview of the organization and architecture of computer systems</li> <li>Introduce students to the concept of abstraction in both problem solving and computer systems</li> <li>Cover the von Neuman Architecture</li> <li>Teach students the binary number system, boolean logic, and digital logic</li> <li>Have students program in Assembly and other low-level machine languages</li> <li>Show the intersection of computer hardware and software</li> </ul>"},{"location":"syllabus/#student-learning-outcomes","title":"Student Learning Outcomes","text":"<p>By the end of this course you will:</p> <ul> <li>Understand the concept of abstraction</li> <li>Be able to explain the Hierarchy of Abstraction in computers and understand which level you are working in</li> <li>Know the general organizational and architectural concepts of computer systems at multiple levels</li> <li>Convert numbers between binary, decimal, and hexadecimal number systems</li> <li>Use basic boolean algebra and k-maps to understand digital logic</li> <li>Design basic circuits using logic gates</li> <li>Understand how transistors are used to built up to more complex systems</li> <li>Create your own Fetch-Decode-Execute systems</li> <li>Simulate/Emulate simple CPU processes using bit manipulation in the C programming language</li> <li>Code in Assembly and other low-level instruction sets</li> </ul>"},{"location":"syllabus/#text-and-materials","title":"Text and Materials:","text":"<p>There is no required text book, most if not all material will be through this site and in class lectures. There are, however suggested resources for those who learn best with a textbook as reference, as well as the sources for the course.</p> <p>\"Digital Design and Computer Architecture\" by Harris and Harris </p> <ul> <li> <p>Textbook that covers a lot of the early information of this course, we will not be covering it exhaustively</p> </li> <li> <p>Not required</p> </li> </ul>"},{"location":"syllabus/#course-schedule","title":"Course Schedule:","text":"<p>Below is the rough topical structure of the course in the order of coverage, you can find this plan and the most updated schedule at the course website. The schedule is a rough outline and will be changed to best serve the classes needs, any changes made will be in favor of the students and any complications can be rectified over email or in-person.</p> <p>These units are a rough organization of the topics in the order covered, they will be about 2-3 weeks each with some time allotted for tests and review. More or less time could be taken depending on the class pace, the latter allowing for more topics to be covered.</p> <ul> <li>Unit Order<ul> <li>Introduction</li> <li>Basic Computer Organization</li> <li>Binary and Digital Logic</li> <li>Circuits, Multiplexers, and Decoders</li> <li>Instruction Set Architectures and Assembly</li> </ul> </li> </ul>"},{"location":"syllabus/#method-of-evaluation","title":"Method of Evaluation","text":"<ul> <li>Homeworks <ul> <li>Take home assignments meant to instill concepts covered in class</li> <li>Will often be based on labs or other in-class activities</li> <li>Mostly coding, short answer, and some drawing</li> </ul> </li> <li>Attendance Quizzes<ul> <li>Short (2-3 Questions) in-person quizzes given weekly</li> <li>Meant to test topics covered the class previous</li> <li>Can be given on any class day during the week</li> <li>No re-tests</li> <li>Three lowest grades dropped from average</li> </ul> </li> <li>Unit Tests<ul> <li>Longer form (10 - 15 Questions) in-person tests given at the end of each unit</li> <li>Given about every three weeks, announced beforehand</li> <li>Will contain short and long answer questions</li> <li>Based on lesson, homeworks, labs, and attendance quizzes</li> <li>Retests given sparingly and under adequate circumstances</li> <li>Lowest grade dropped from average</li> </ul> </li> <li>Labs<ul> <li>Ungraded guided exercises that are covered in class </li> <li>Students will start them in class and finish them on their own</li> <li>Will prepare students for both homeworks and tests</li> </ul> </li> </ul> Academic Work % of Grade Homework 60% Attendance Quizzes(Weekly) 10% Unit Tests 30% Labs(in-class) Ungraded Total 100%"},{"location":"syllabus/#letter-grading","title":"Letter Grading","text":"Letter Grade Percentage Range A+ 96\u2154 - 100% A 93\u2153 - 96\u2154% A- 90 - 93\u2153% B+ 86\u2154 - 90% B 83\u2153 - 86\u2154% B- 80 - 83\u2153% C+ 76\u2154 - 80% C 73\u2153 - 76\u2154% C- 70 - 73\u2153% D+ 66\u2154 - 70% D 63\u2153 - 66\u2154% D- 60 - 63\u2153% F 0 - 60%"},{"location":"syllabus/#accommodations-for-students-with-accessibility-needs-at-suny-polytechnic-institute","title":"Accommodations for Students with Accessibility Needs at SUNY Polytechnic Institute:","text":"<p>Your access in this course is important to me. In compliance with the Americans with Disabilities Act of 1990 and Section 504 of the Rehabilitation Act of 1973, SUNY Polytechnic Institute is committed to ensuring comprehensive educational access and accommodations for all registered students seeking access to meet course requirements and fully participate in programs and activities. Students with documented disabilities, temporary, or medical conditions are encouraged to request services by contacting Student Accessibility Services (SAS) or filling out the Request for Accommodations form. Please note, requesting accommodations is only the first step. You must provide documentation (the request form may count) to SAS and meet with staff before receiving accommodations. Please do this as early as possible 1) because accommodations are never retroactive and 2) so that we have adequate time to arrange your approved academic accommodation/s.</p> <p>Once SAS creates your accommodation plan, it is your responsibility to provide me a copy of the accommodation plan. If you experience any access barriers in this course, such as with printed content, graphics, online materials, etc., reach out to me or SAS right away. For information related to these services or to schedule an appointment, please contact SAS using the information provided below.</p>"},{"location":"syllabus/#office-of-student-accessibility-services","title":"Office of Student Accessibility Services","text":"<p>Email: SAS@sunypoly.edu</p> <p>Phone: (315) 792-7170</p> <p>Location: Kunsela Hall, B101</p>"},{"location":"syllabus/#content-accessibility","title":"Content Accessibility","text":"<p>SUNY Poly\u2019s goal is for all digital content to be fully accessible but there may be times when remediation is still underway, please let me know if you experience challenges accessing any digital content in this course.</p> <p>This course is attempting to start a new standard for the CS department using open-source tools to make content universally accessible according to any accessibility requirements by producing all content sources in Markdown. By creating it in Markdown and pure text, any accessibility reader can be tooled to a students needs, while allowing for the teacher to rapidly create material in a lasting way.</p> <p>This process will not be without its bumps, so, if there are any issues with accessing the course material or reading it in any way, please contact me ASAP by email at szwakoj@sunypoly.edu.</p>"},{"location":"syllabus/#pregnancy-statement","title":"Pregnancy Statement","text":"<p>SUNY Poly is committed to fostering an inclusive and supportive environment for all students and it does not discriminate against any student based on the student's pregnancy or related conditions. If you have questions or concerns related to pregnancy or related conditions, please contact the Title IX Coordinator, Kathie Artigiani at artigik@sunypoly.edu.</p>"},{"location":"syllabus/#technical-assistance-for-students","title":"Technical Assistance for Students","text":"<p>The following only applies for technologies and materials offered by the school generally and not the ones that this course uses individually. If there are any issues with the course website, programming tools, or homeworks, email the teacher.</p> <p>The SUNY Poly Help Desk is in the Cayan Library on the first floor. You can contact them by phone at 315-792-7440, by email at helpdesk@sunypoly.edu, or by submitting an online help ticket on their website.</p> <p>If the SUNY Poly Help Desk is closed, you can obtain assistance from the Open SUNY Help Desk by calling 1-844-OPENSUNY (673-6786). The Open SUNY email is OpenSUNYHelp@suny.edu or you can submit an online help ticket.</p> <p>The SUNY Poly ITS website has information about software and hardware that you can access as a student, as well as links to software you may need in your classes. Students are encouraged to save all work in multiple locations. MS Office OneDrive is available for use. For assistance, please contact the ITS Help Desk, helpdesk@sunypoly.edu or 315-792-7440. </p>"},{"location":"syllabus/#academic-integrity-and-code-of-conduct","title":"Academic Integrity and Code of Conduct","text":"<p>SUNY Poly is committed to academic excellence in a climate of honesty, respect, and trust. The mutually respectful exchange of honest ideas is foundational to the intellectual vigor of the SUNY Poly community. The University seeks to maintain and enhance its educational environment through the development, promotion, and enforcement of standards for academic integrity. Please take a few minutes to become familiar with SUNY Poly\u2019s Community Standards, including the Student Handbook and Student Code of Conduct. SUNY Poly\u2019s Academic Integrity Policy, which describes SUNY Poly\u2019s policies regarding plagiarism and other inappropriate academic activities, can be found in the Student Handbook. </p>"},{"location":"syllabus/#writing-and-communications-center","title":"Writing and Communications Center","text":"<p>The Writing and Communications Center (WCC) is here to support all of SUNY Poly\u2019s writers: students, faculty, and staff. We offer one-on-one in-person and remote consultations for writers working on a range of projects at any stage of the writing process (from idea generation to final revisions). WCC consultants work with writers on idea development, brainstorming, content development, structure, source use, style, grammar, punctuation, and more. While we are not a proofreading or editing service and we do not comment on grades, we offer strategies and resources writers can use as they compose, revise, edit, and learn to proofread their own work. The WCC is located on the first floor of the Cayan Library. You can learn more about the WCC or make an appointment by visiting our website: https://sunypoly.edu/writingcenter.html.</p>"},{"location":"syllabus/#plagiarism-warning","title":"Plagiarism Warning","text":"<p>All homeworks, quizzes, tests, and labs are meant to be completed by students independently (unless otherwise stated) and without the assistance of generative AI backed by LLMs including, but not limited to, ChatGPT, Claude, Gemini, and all other text/code generators. All material that is assigned to students is meant to instill lasting critical thinking and problem solving skills that are required to excel in both this course and wherever students may end up in the future. As such, usage of these tools in a fashion akin to plagiarism (not citing, wholesale copying, intent to hide sources) is strictly prohibited in this course. All incidents that can be proven must be brought to the dean and always results in a zero on the grade. This goes for plagiarizing code from other sources, such as StackOverflow, Reddit, Github, other uncited sources, and fellow students.</p> <p>That being said, using other sources as reference is not completely out of the question. Peers, tutorials, YouTube videos, existing code, and even LLMs can greatly aid in understanding complex topics. However, they cannot be used without disclosure and proper citation if being used extensively in an assignment. Use other sources and LLMs cautiously as this course is based on the lessons found within the the lectures given in-person.</p>"},{"location":"syllabus/#policy-on-submission-of-assignments","title":"Policy on Submission of Assignments","text":"<p>All assignments will be submitted via Brightspace in the appropriate location identified by each assignment. Specific instructions can be found on the course website. Each assignment will be given with an intended due date attached. For each day late an assignment is, a 10% reduction will be removed from the maximum possible grade, capped at 50%, so long as a valid final submission has been made by the end of the semester.</p>"},{"location":"syllabus/#policy-on-missed-classes-make-up-work-andor-extra-credit","title":"Policy on Missed Classes, Make-up Work, and/or Extra Credit:","text":"<p>There is no method of attendance other than the attendance quizzes given weekly</p>"},{"location":"syllabus/#cancellation-of-classes-due-to-inclement-weather-or-other-emergency","title":"Cancellation of Classes Due to Inclement Weather or Other Emergency:","text":"<p>SUNY Poly has a 24-hour hotline, called Snowline, to inform students, faculty, and staff when severe weather prompts the cancellation of all classes. Snowline can be reached by calling 315-792-7385. In the event of severe weather, Snowline will announce only the cancellation of ALL classes. The cancellation of all classes will also be posted online and broadcast on radio and television stations in the Utica Rome and Syracuse areas. The SUNY Poly website also maintains a list of individual class cancellations.</p> <p>In addition, all SUNY Poly students and employees are enrolled in the Rave Alert emergency alert service. You can visit the SUNY Poly Rave Alert website to learn more and to adjust your notification preferences. </p>"},{"location":"homework/1_c_review/","title":"C Review: Binary Image Memory Reading/Writing","text":""},{"location":"homework/1_c_review/#due-date-22726","title":"Due Date: 2/27/26","text":""},{"location":"homework/1_c_review/#description","title":"Description","text":"<p>In this homework, you will be learning to manipulate information using raw binary. In order to visualize the various binary operations we are doing, we will be using the PBM/PGM/PPM  image formats as a way of quickly writing pixel information directly to memory.</p> <p>For more info on the PBM/PGM/PPM file format, the Wikipedia page for them is a pretty good resource along side the specifications that I could find:</p> <ul> <li>Netpbm Wikipedia Page</li> <li>Netpbm Specifications<ul> <li>PBM Spec</li> <li>PGM Spec</li> <li>PPM Spec</li> </ul> </li> </ul> <p>The spark notes version is that \"Netpbm\" or \"Network Portable Bitmap Format\" is a collection of tools and specifications for portable graphics file formats. They have three main types of portable formats that can be opened by nearly any text editor:</p> <ul> <li>PBM (Portable BitMap Format) - Each pixel is either a 1 or 0, for white or black respectively</li> <li>PGM (Portable GreyMap Format) - Typically, each pixel can be any number between 0-255 signifying how grey the pixel is, with 0 being black and 255 being white</li> <li>PPM (Portable PixMap Format) - Each pixel now has three numbers ranging from 0-255, for each red, green, and blue color channels</li> </ul> <p>Each type of file defines ways of writing pixels to an image file in a very general way, it is so general I can show the raw form of the file format. The basic one, PBM, binary numbers, 0 to turn off a pixel and 1 to turn it on. The following .pbm file stores a happy face:</p> <pre><code>P1\n10 10\n1\n0 0 0 0 0 0 0 0 0 0\n0 0 1 0 0 0 0 1 0 0\n0 0 1 0 0 0 0 1 0 0\n0 0 1 0 0 0 0 1 0 0\n0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 0 0 0 1\n0 1 0 0 0 0 0 0 1 0\n0 0 1 1 1 1 1 1 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n</code></pre> <p>Let's explain line-by-line:</p> <ol> <li><code>P2</code> - This is the \"magic number\" it ultimately decides what format we are using. <code>P2</code> specifically refers to the Portable GreyMap Format in ascii, rather than in raw bytes, more on this later.</li> <li><code>10 10</code> -  After the magic number, there is two numbers to represent the width and height in that order. These are used to read the rest of the file, automatically making sure that each pixel is put in the correct location.</li> <li><code>1</code> - This is the scale of all of the numbers, this is saying that the grey scale is maxed at 1 meaning there is only black, 0, and white 1</li> <li><code>0 0 0 0 ...</code> - This is the actual contents of the file. For black and white grey scale images each number represents the value for that pixel to be drawn to the screen.</li> </ol> <p>That \"magic number\" is the format that is used for identifying how the data will be stored, either as ascii chars that are viewable, or raw binary format for being compact and closer to reality. These are the magic numbers for <code>.pbm</code>, <code>.pgm</code>, and <code>.ppm</code></p> <ul> <li><code>P1</code>, <code>P2</code>, <code>P3</code> = ASCII format (human-readable)</li> <li><code>P4</code>, <code>P5</code>, <code>P6</code> = Raw binary format (more compact)</li> </ul> <p>Fortunately, Sublime Text and other text editors like VSCode and view this images as they live update. Unfortunately, Sublime Text only supports it for <code>.pgm</code> and <code>.ppm</code> and only in magic number modes <code>P5</code> and <code>P6</code>, meaning you will only be able to view the ones after you have generated in binary. With this in mind, we will be focusing on <code>.pgm</code> and <code>.ppm</code> and be generating in raw binary and then viewing the files.</p> <p>These types of files were picked for this assignment because they are a simple format that represents very closely to how we write directly to memory. With this in mind, we will only be allowing the the use of C binary and hexadecimal numbers for all values other than powers of 2 (0, 1, 2, 4, 8, 16, ...) and heavily relying on C binary/bitwise operators.</p> <p>To use C binary and hexadecimal number representations:</p> <ul> <li>Prefix with <code>0b</code> for binary numbers<ul> <li><code>0b1010</code> for the number 10</li> </ul> </li> <li>Prefix with <code>0x</code> for hex numbers<ul> <li><code>0xABC</code> for the number 2748</li> </ul> </li> </ul> <p>Using these ideas in this homework you will:</p> <ul> <li>Write/edit simple binary images in black and white</li> <li>Write more complex color images</li> </ul> <p>Section 1: Black and White &amp; Greyscale Images</p> <ul> <li>Random Noise (BW and Greyscale)</li> <li>Bit-Plane an Image</li> <li>Bitwise Patterns</li> </ul> <p>Section 2: Color Images</p> <ul> <li>Random Noise </li> <li>Bitwise Patterns</li> <li>Bit-Plane an Image</li> <li>Color Channel Fragmentation and Mixing</li> </ul>"},{"location":"homework/1_c_review/#section-1-black-and-white-greyscale-images","title":"Section 1: Black and White &amp; Greyscale Images","text":"<p>Click here, to download the starting point that I have created for you. It is also on Brightspace, under Content-&gt;Homework 1. Unzip it into the place you are completing Homework 1, Section 1. </p> <p>This code will output a simple greyscale image that is a gradient that goes from left to right. Nothing special.</p> <p>It also contains the images you will read in and use for the parts that require inputs.</p>"},{"location":"homework/1_c_review/#overview","title":"Overview","text":"<p>Using the starting point as a going off point you are to create a C project with two main files for this section:</p> <ol> <li><code>black_and_white.c</code> - Function declarations for each problem without them being used</li> <li><code>main.c</code> - Using all of the aforementioned functions to generate all images in the current directory with correct names<ol> <li>Should <code>#include \"black_and_white.c\"</code></li> </ol> </li> </ol> <p>All generated images are to be saved as <code>.pgm</code> files in this section.</p>"},{"location":"homework/1_c_review/#task-1-random-noise-generator-15-points","title":"Task 1: Random Noise Generator (15 points)","text":"<p>Create a function that generates random noise images in both black &amp; white and greyscale</p> <p>Function signature:</p> <pre><code>void generate_random_noise_bw(const char* filename, int width, int height);\nvoid generate_random_noise_grey(const char* filename, int width, int height);\n</code></pre> <p>Requirements:</p> <ul> <li>Use <code>rand()</code> to generate random pixel values</li> <li>For black &amp; white: each pixel should be randomly 0 or 1<ul> <li>This means that the max value must be set at 1</li> </ul> </li> <li>For greyscale: each pixel should be a random value between 0-255</li> <li>Write in binary format (P5)</li> <li>Both images should be 256x256 pixels</li> </ul> <p>Hints:</p> <ul> <li>Use <code>rand() % 2</code> for binary values</li> <li>Use <code>rand() % 0xFF</code> for greyscale values</li> <li>Remember to seed the random number generator with <code>srand(time(NULL))</code> in main</li> </ul>"},{"location":"homework/1_c_review/#task-2-bit-plane-extraction-20-points","title":"Task 2: Bit-Plane Extraction (20 points)","text":"<p>Create a function that extracts individual bit planes from a greyscale image.</p> <p>Function signature:</p> <pre><code>void extract_bit_plane(const char* input_file, const char* output_file, int bit_position);\n</code></pre> <p>Requirements:</p> <ul> <li>Read a PGM image</li> <li>Extract the specified bit plane (0-7, where 0 is LSB and 7 is MSB)</li> <li>Create a new PGM where pixels are either 0 or 255 based on that bit</li> <li>Use bitwise AND operation to check if a bit is set</li> <li>Must use binary/hex number representation (0b...)(0x...)</li> </ul> <p>Example: If a pixel value is <code>0b10110101</code> (181):</p> <ul> <li>Bit plane 0 (LSB): 1 \u2192 output 255</li> <li>Bit plane 4: 0 \u2192 output 0</li> <li>Bit plane 7 (MSB): 1 \u2192 output 255</li> </ul>"},{"location":"homework/1_c_review/#task-3-bitwise-pattern-generation-25-points","title":"Task 3: Bitwise Pattern Generation (25 points)","text":"<p>Create functions that generate images using bitwise operations on pixel coordinates.</p> <p>Function signatures:</p> <pre><code>void generate_xor_pattern(const char* filename, int width, int height);\nvoid generate_and_pattern(const char* filename, int width, int height);\nvoid generate_or_pattern(const char* filename, int width, int height);\n</code></pre> <p>Requirements:</p> <ul> <li>For each pixel at position (x, y), calculate the pixel value using:<ul> <li>x XOR y</li> <li>x AND y</li> <li>x OR y</li> </ul> </li> <li>All operations must use binary operators and hex notation </li> <li>Generate 256x256 images</li> <li>Output as PGM files</li> </ul> <p>Hints:</p> <ul> <li>These operations create interesting geometric patterns</li> <li>The XOR pattern is particularly famous for creating diagonal lines</li> </ul>"},{"location":"homework/1_c_review/#section-1-grading-rubric","title":"Section 1 Grading Rubric","text":"<ul> <li>Task 1: Random noise generation (15 points)</li> <li>Task 2: Bit-plane extraction (20 points)</li> <li>Task 3: Bitwise patterns (25 points)</li> <li>Code style and comments (10 points)</li> <li>Proper binary/hex notation usage (10 points)</li> <li>Memory management (10 points)</li> <li>Proper file I/O (10 points)</li> <li>Total: 100 points</li> </ul>"},{"location":"homework/1_c_review/#section-2-color-images","title":"Section 2: Color Images","text":""},{"location":"homework/1_c_review/#overview_1","title":"Overview","text":"<p>Now you'll work with PPM (color) images. Each pixel has three color channels: Red, Green, and Blue, each ranging from 0-255.</p> <p>This calls for the <code>P6</code> magic number.</p> <p>In the section folder, create a new file <code>color_images.c</code> with the following functions and use them in <code>main.c</code> the same as the previous.</p>"},{"location":"homework/1_c_review/#task-1-color-random-noise-15-points","title":"Task 1: Color Random Noise (15 points)","text":"<p>Create a function that generates random color noise.</p> <p>Function signature:</p> <pre><code>void generate_random_noise_color(const char* filename, int width, int height);\n</code></pre> <p>Requirements:</p> <ul> <li>Generate 256x256 image</li> <li>Each color channel (R, G, B) should be random (0-255)</li> <li>Write in binary format (P6)</li> <li>Must write RGB values sequentially for each pixel</li> </ul>"},{"location":"homework/1_c_review/#task-2-color-bitwise-patterns-20-points","title":"Task 2: Color Bitwise Patterns (20 points)","text":"<p>Create functions that generate color patterns using bitwise operations.</p> <p>Function signatures:</p> <pre><code>void generate_rgb_pattern_1(const char* filename, int width, int height);\nvoid generate_rgb_pattern_2(const char* filename, int width, int height);\nvoid generate_rgb_pattern_3(const char* filename, int width, int height);\n</code></pre> <p>Requirements:</p> <ul> <li>Create three DIFFERENT color pattern generators</li> <li>Each function must generate a 256x256 PPM image</li> <li>Each color channel (R, G, B) must be calculated using a DIFFERENT combination of:<ul> <li>The pixel's x-coordinate</li> <li>The pixel's y-coordinate</li> <li>At least TWO different bitwise operations per pattern</li> </ul> </li> <li>You must use at least 4 of these bitwise operations across all three patterns:<ul> <li>XOR (<code>^</code>)</li> <li>AND (<code>&amp;</code>)</li> <li>OR (<code>|</code>)</li> <li>Left shift (<code>&lt;&lt;</code>)</li> <li>Right shift (<code>&gt;&gt;</code>)</li> <li>NOT (<code>~</code>)</li> </ul> </li> <li>Each channel's formula must produce values in the range 0-255</li> <li>You may NOT use the same formula for all three channels in a single pattern</li> <li>All numeric constants must be in hexadecimal (0x...) or binary (0b...) notation</li> </ul> <p>Examples of valid operations:</p> <pre><code>// Using coordinates with bitwise ops\nR = (x ^ y) &amp; 0xFF;           // XOR coordinates, mask to byte\nG = ((x &lt;&lt; 2) | y) &amp; 0xFF;    // Shift and OR\nB = (~(x &amp; y)) &amp; 0xFF;        // AND then invert\n</code></pre> <p>Grading:</p> <ul> <li>Pattern 1: Uses at least 2 different bitwise operators (7 points)</li> <li>Pattern 2: Uses at least 2 different bitwise operators, different from pattern 1 (7 points)</li> <li>Pattern 3: Most creative/interesting pattern (6 points)</li> </ul> <p>Hints:</p> <ul> <li>Start by experimenting with simple combinations</li> <li>The <code>&amp; 0xFF</code> operation ensures your result stays in 0-255 range</li> <li>Different shift amounts create different visual effects</li> <li>Combining operators (like <code>(x ^ y) &amp; (x | y)</code>) creates complex patterns</li> <li>View your images to see if they're interesting before submitting!</li> </ul>"},{"location":"homework/1_c_review/#task-3-bit-plane-color-extraction-20-points","title":"Task 3: Bit-Plane Color Extraction (20 points)","text":"<p>Extract bit planes from color images for each channel separately.</p> <p>Function signature:</p> <pre><code>void extract_color_bit_plane(const char* input_file, const char* output_file, \n                             char channel, int bit_position);\n</code></pre> <p>Requirements:</p> <ul> <li><code>channel</code> parameter: 'R', 'G', or 'B'</li> <li>Extract specified bit plane from chosen channel</li> <li>Output a greyscale PGM showing that bit plane</li> <li>Other channels' bits should be ignored</li> </ul> <p>For this ones implementation, show each channel in a different image.</p>"},{"location":"homework/1_c_review/#task-4-channel-fragmentation-and-mixing-25-points","title":"Task 4: Channel Fragmentation and Mixing (25 points)","text":"<p>Create functions to separate and recombine color channels.</p> <p>Function signatures:</p> <pre><code>void separate_channels(const char* input_file, const char* r_out, \n                       const char* g_out, const char* b_out);\nvoid mix_channels(const char* input_file_a, const char* input_file_b, \n                    const char* output_file);\n</code></pre> <p>Requirements:</p> <ul> <li><code>separate_channels</code>: Create three color images, for each color channel, where all other color channels are removed</li> <li><code>mix_channels</code>: Take two images and xor their color channels together</li> </ul>"},{"location":"homework/1_c_review/#section-2-grading-rubric","title":"Section 2 Grading Rubric","text":"<ul> <li>Task 1: Color random noise (15 points)</li> <li>Task 2: Color bitwise patterns (20 points)</li> <li>Task 3: Color bit-plane extraction (20 points)</li> <li>Task 4: Channel operations (25 points)</li> <li>Code style and comments (10 points)</li> <li>Proper binary/hex notation (10 points)</li> <li>Total: 100 points</li> </ul>"},{"location":"homework/1_c_review/#submission-guidelines","title":"Submission Guidelines","text":""},{"location":"homework/1_c_review/#what-to-submit","title":"What to Submit","text":""},{"location":"homework/1_c_review/#section-1-in-folder-named-section1","title":"Section 1 (in folder named <code>section1/</code>):","text":"<ul> <li><code>black_and_white.c</code> - Your function implementations</li> <li><code>main.c</code> - Driver program that calls all functions</li> <li>All generated <code>.pgm</code> files from your program</li> </ul>"},{"location":"homework/1_c_review/#section-2-in-folder-named-section2","title":"Section 2 (in folder named <code>section2/</code>):","text":"<ul> <li><code>color_images.c</code> - Your function implementations</li> <li><code>main.c</code> - Driver program that calls all functions (can include black_and_white.c if you want both sections in one main)</li> <li>All generated <code>.ppm</code> and <code>.pgm</code> files from your program</li> </ul>"},{"location":"homework/gcc_install/","title":"Installation Process","text":""},{"location":"homework/gcc_install/#gcc-install","title":"GCC Install","text":"<p>GCC or the GNU Compiler Collection is an open source collection of programming tools for lower-level languages like C, C++, FORTRAN, and Assembly. We will be using it to compile and run the programs for demos and homeworks using it.</p>"},{"location":"homework/gcc_install/#windows","title":"Windows","text":"<p>There are many methods to install gcc on Windows-based system, each attempting to stream-line some part of the process. We will be using WinLibs GCC pre-compiled version of the collection and manually adding it to the PATH so that you may use the programs in Windows CMD.</p> <ol> <li>Go to https://winlibs.com/:    </li> <li>Scroll down to the Download section:    </li> <li>Click on the red-circled \"Download it here\" to download the latest release for Windows 64-bit systems. If you need the 32-bit version for some reason, it is below. All modern computers are 64-bit so you should be fine with that.</li> <li>That will download a zip file inside of your \"Downloads\" folder:    </li> <li>Right click on the file and select \"Extract All\", or use the top tools to select the same option as in the image:    </li> <li>That will open up a new dialog box asking where to extract the file contents to, click \"Browse\":    </li> <li> <p>Using the File Explorer's side bar menu, scroll down to find \"This PC-&gt;C:\", click it, then press the \"Select Folder\" button, as indicated:    </p> </li> <li> <p>Click \"Extract\", and wait for the process to complete:</p> </li> <li> <p>The compiler is now installed, however your windows Command Prompt cannot use the compiler and other tools until their locations have been added to the PATH. Click the search bar on the task bar and search for  \"environment variables\", click on the \"Edit the system environment variables\" option:    </p> </li> <li>Click on the \"Environment Variables...\" button:     </li> <li>With the new menu that pops up, click on the \"Path\" option under \"System variables\", NOT the one that is for your account. With that selected click on the \"Edit...\" button:     </li> <li>In the new window, click \"New\" to add a new line to the PATH, then click \"Browse...\":     </li> <li>With the new file explorer open, go to \"This PC-&gt;Local Disk (C:)-&gt;mingw64-&gt;bin\", with \"bin\" as the selected folder:     </li> <li>Click \"OK\"</li> <li>Click \"OK\"</li> <li>Click \"OK\"</li> <li>Click \"OK\"</li> <li>GCC has now been installed on your Windows computer! To test this, search cmd in the search bar to open the command prompt</li> <li>Type <code>gcc</code>, and press enter</li> <li>This should result in the following error:     </li> <li>If something else happens, try the process again pay sure to follow the instructions and that you are always downloading and installing into local directories and not those on \"OneDrive\" or other such networked drives</li> <li>If you continue to struggle, bring it up in class, or email me</li> </ol>"},{"location":"homework/gcc_install/#mac","title":"Mac","text":"<p>Apple products have their own suite of gcc tools installed by default, but to be sure that you have full access to them, we will be installing the GNU versions via Homebrew.</p> <ol> <li>Go to https://brew.sh/</li> <li>Follow the instructions there to install brew. It should be<ol> <li>Open macOS terminal</li> <li>Copy-Paste the command below    <code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"</code></li> <li>Run and let it do its thing</li> </ol> </li> <li>With that installed, keep the terminal open and type: <code>brew install gcc</code></li> <li>And you are all done, you should now have access to the gcc command</li> <li>You may test it similarly to the Windows test above, when run without any files given it should produce an error that says \"no input files\". If it says command not found, something is wrong and contact me.</li> </ol>"},{"location":"homework/gcc_install/#linux","title":"Linux","text":"<p>Usually during the installation process you install gcc and the other build tools as a consequence. If not just use your native package manager and install gcc.</p>"},{"location":"homework/gcc_install/#text-editor-or-ide-install","title":"Text Editor or IDE Install","text":"<p>There is no required text editor for this course, however for nearly all of the in-class demos I will be using Sublime Text as my primary text editor. </p> <p>Integrated development environments or IDEs are a little too high-level for courses and remove some of the learning process for students. They also may end up becoming topics to learn in themselves. So, while there is no hard ban on students using tools like VScode or other powerful coding platforms, I strongly suggest the use of simple text editors like Sublime Text.</p> <p>To install Sublime Text, go to https://www.sublimetext.com/ and it will have a specialized installation process for your system on the website. Just click the button that says \"Download for (YOUR SYSTEM)\", and follow the instuctions.</p>"},{"location":"homework/how_to_hand_in/","title":"How To Hand In","text":"<p>During this semester we will have different kinds of assignments meant to aid in understanding, test your skills, and prepare you for the later examinations.</p>"},{"location":"homework/how_to_hand_in/#format-of-submissions","title":"Format of Submissions","text":"<p>Depending on the format of the assignment, you may be asked to produce different types of artifacts to accomplish the given problem set, sometimes multiple different kinds in a single set. </p> <p>Some of the most common type of problems in the HWs will be, along with the general guidelines of how they should be presented:</p> <ul> <li>Coding Problems - Problems that require the generation of source code that meets all requirements of the HW specification<ul> <li>Hand this in as the source code files with the intended programming language file extension</li> <li>Unless told specifically, DO NOT include executables or binaries made for YOUR system. Only hand in source code</li> </ul> </li> <li>Written Problems - These will have you generating natural language responses for a given prompt, length varying and specified in each problem<ul> <li>These can be handed in the following file types:<ul> <li>.txt, .md, .pdf, .docx</li> </ul> </li> <li>If you intend to hand-write answers, you may, however write legibly and scan your answers in one of the following types<ul> <li>.pdf, .png, .jpg</li> </ul> </li> </ul> </li> <li>Drawing Problems - At times I will ask for images to be generated by you as assignments, these can be completed by hand, on tablets, or using some drawing software<ul> <li>Hand these in similarly to the above, in fact at times written and drawing problems may be in a single section</li> </ul> </li> </ul>"},{"location":"homework/how_to_hand_in/#organization-of-files","title":"Organization of Files","text":"<p>Many assignments will contain multiple parts or sections in each, requiring the creation of multiple files in the same and different file types. To keep everything organized with how I am expecting the submissions we will be following the structure below:</p> <ul> <li>Each completed homework should be submitted as a single .zip file that contains:<ul> <li>A folder for each section of homework containing:<ul> <li>All generated files from that section in appropriate file types as listed above</li> </ul> </li> </ul> </li> </ul> <p>For example, if there was the following homework:</p> <ul> <li>Homework 0: Fake Homework<ul> <li>Section 1: Do some code<ul> <li>Code 1</li> <li>Code 2</li> </ul> </li> <li>Section 2: Do some writing<ul> <li>Questions</li> </ul> </li> <li>Section 3: Do some drawing<ul> <li>Questions</li> </ul> </li> </ul> </li> </ul> <p>The file structure should look like this: <pre><code>CS240-HW0-LastNamezip\n\u251c\u2500\u2500 Section1/\n\u2502   \u251c\u2500\u2500 code1.c\n\u2502   \u2514\u2500\u2500 code2.c\n\u251c\u2500\u2500 Section2/\n\u2502   \u2514\u2500\u2500 answers.txt\n\u2514\u2500\u2500 Section3/\n    \u2514\u2500\u2500 drawings.png\n</code></pre></p> <p>If you noticed, I also have an intended naming scheme. Name the overall .zip submission in the form \"CS240-HW{HW number}-{Student Last Name}.zip\". Each section and file will be specified individually for each assignment, be sure to pay attention to it.</p>"},{"location":"homework/how_to_hand_in/#where-to-hand-in","title":"Where to hand in","text":"<p>While the course material and the homework problems are posted here, on this website, all submissions of assignments will be done on the SUNY Poly's Brightspace system. This will also be where all of your grades for assignments and quizzes will be located. This is to ensure grades are in a single place as well as utilize Brightspace's submission system.</p> <p>I will show this off in class and generate images of the process at a later date, however most if not all other courses at SUNY Poly use Brightspace, so I am sure you are acquainted  with it. </p>"},{"location":"labs/c_compilation/","title":"C Compilation Objects","text":"<p>To go from human-readable C code to a running program on a computer requires a few steps of processing before being converted to the machine code that ultimately is what the computer runs on the CPU. </p> <p>This lab will use a few <code>gcc</code> command flags to extract our those intermediate forms of the program we made. To reiterate the compilation process in the C review lesson, there are four main steps in C compilation: 1. Preprocessing: The C preprocessor (CPP) formats the source code using macros like <code>#include</code> or <code>#define</code>, including needed headers and applying any user-defined changes before passing to the next step 2. Compilation: The compiler translates C source code into assembly language 3. Assembly: The assembler then converts the assembly code into machine code, producing object files, <code>.o</code> or <code>.obj</code>, as a result 4. Linking: The linker orders the object files properly and combines them into a single executable program that is ready to run on the target system</p> <p>Each one of these steps produces distinct products that we can look closer at to understand the process a bit more. In order to do that, we will need another tool to be added to our system PATHs. <code>xxd</code> is a command-line tool </p>"},{"location":"lessons/1_introduction/","title":"Introduction","text":"<p>Welcome to CS 220 - Computer Organization! This lesson's purpose is to set the stage and better understand what information will be covered in the course. Computer Organization is a broad topic with many possible deep wells to fall into. In this course, we will attempt to cover a big picture view into how computers work at multiple levels of abstraction, exploring the many facets that each has. Here we introduce:</p> <ul> <li>Computers</li> <li>Turing Machines</li> <li>The Abstraction Hierarchy</li> <li>Von Neumann Model</li> <li>Programming Language Abstraction</li> </ul>"},{"location":"lessons/1_introduction/#computers","title":"Computers","text":"<p>Computers have infiltrated every part of our lives either indirectly or directly for some time now. They sit at the core of every financial transaction, recreational activity, and many social relationships that most human beings experience for the last 20 years. Because of this and the choices that led you to CS, it is highly important to understand computers on a deep level for both career success and for designing a better future.</p> <p>The word computer has historically taken on different meanings, however at its most basic is \"a thing that computes\". The first named computers were human, people who would sit at desks and do repeated numerical calculations for businesses and institutions. The first object to fit the definition \"a thing that computes\" goes very far back, as far back as the first recorded civilizations. </p> <p>Evidence of Sumerian abacuses has been dated between 2700 and 2300\u00a0BC, with other examples of clay tablets used to aid in mathematical calculations. </p> <p></p> <p>However, in the modern day, when one says \"computer\" we do not think about times tables and abacuses, we are talking about digital computers (as opposed to the previous analog computers). </p>"},{"location":"lessons/1_introduction/#analog-and-digital-computers","title":"Analog and Digital Computers","text":"<p>Analog computers are devices that model predetermined calculations through the use of voltage, gears, pulleys, or other phenomenon that is related to the calculation in question. Examples include:</p> <ul> <li>Sphere-based tidal predictions (Link)</li> <li>The Antikythera Mechanism (Link)</li> <li>Slide Rulers (Link)</li> <li>Mechanical Calculators (Link) </li> </ul> <p>These computers are:</p> <ul> <li>Purpose built - they cannot be reprogrammed and must have their purpose defined beforehand</li> <li>No memory - they do not store memory or act on some bank of stored information that is able to be rewritten</li> <li>Difficult to use - since their design and purpose are so tied, often they were unintuitive to use to the uninitiated, also there were no commonalities between two different analog computers  </li> </ul> <p>Digital computers are the modern devices that use discrete numbers to symbolically represent information and does operations on that data using a finite set of general operations. Today, they are made of transistors, small electrical components that can either block or allow pass a electrical signal depending on whether itself is being fed an electrical signal. These transistors are used to make logic gates that are copied and repeated billions of times to form the modern idea of a computer. These computers are:</p> <ul> <li>General Purpose - they can be made general and can complete any computation task</li> <li>Possess Writable Memory - by having a store of memory it can store programs that change its behavior and store intermediate information</li> <li>Expandable - Interfaces can be developed over time to make working with the computer easier, programs can be rewritten to fix mistakes. Overall, it is easy to use.</li> </ul>"},{"location":"lessons/1_introduction/#turing-machines","title":"Turing Machines","text":"<p>The modern idea of a general-purpose computer or \"Universal Computing Machine\" was developed by Alan Turing in 1936 with his paper On Computable Numbers. There he proposed such a machine, referred today as a \"universal Turing Machine\", and proved that it was capable of computing anything that is computable by executing instructions stored in memory. Although theoretical in nature, we use the idea of a Turing machine to see if a device meets the criteria of being able to compute anything that is computable; if it is Turing-complete.  </p> <p></p> <p>Any machine can be called Turing-complete so long as it is able to:</p> <ul> <li>Read and write data to memory</li> <li>Perform conditional branching</li> <li>Loop or repeat operations</li> <li>The possibility of having infinite memory<ul> <li>This means that the fundamental mechanism is not limited in its access in memory. Even though infinite memory is physically impossible, we can expand to allow for it to be approached</li> </ul> </li> </ul> <p>So long as a device can do the above and simulate a Turing machine, it is Turing-complete, regardless of what it is made out of, or how it accomplishes the above. Modern digital computers use transistors and boolean logic to build up to a general computing system. </p>"},{"location":"lessons/1_introduction/#transistors-to-desktops","title":"Transistors to Desktops","text":"<p>The conceptual journey of understanding how we are able to do anything with enough transistors will be a central theme to the course.  To demonstrate the overall, big-picture view of a computer and working at these different conceptual layers, computer scientists often use layered abstraction diagrams to organize the many logical structures that build on top of one another.</p> <p></p> <p>In this Abstraction Hierarchy, we can see that working at the application layer is most abstract from what is actually happening at the physical level. Rarely do we ever need to worry about overflowing a memory register when playing Minecraft or Word. Most of the time, as programmers, we work within the \"Programming Language\" and \"Algorithm\" layers, since this is where software development takes place. However, in order to interact with the computer in such a way there are a lot of steps that need to happen before we get to use <code>printf()</code>. </p> <p>At the bottom of the hierarchy is \"Electronics and Physics\", these are the natural laws that we harness to represent information. If it was not for the way that electricity flows through wires and our intelligent manipulation of it, the modern computer would not exist. Electricity is not the only method of representing computation, in fact we are trying to find new ways of accomplishing computation:</p> <ul> <li>Quantum Computers - Using quantum particles to represent computation</li> <li>Optical Computing - A growing research field in unconventional computation methods is using light to store and operate on data</li> <li>DNA Computing - The very programming language our body runs on can be harnessed to run many repeated operations in a fraction of the time it takes for electronic based computers, although very specialized and very difficult to read the results at the end</li> </ul> <p>The main way we channel electricity to compute is by use of transistors and other electronics components. Transistors are essentially electrical switches that are themselves controlled by an electric signal. They function like this:</p> <p></p> <p>Transistors have two states, on and off, giving the smallest unit of information, a bit. On and off map directly to True and False, allowing a critical connection to boolean algebra and enabling the construction of logic gates. These logic gates are a bridge that facilitate building more complex systems from the natural phenomenon of electricity. These logic gates are used to build systems that allow for arithmetic to be done using binary numbers, store memory, and control other parts of the computers architecture. Each one of these components are organized according to a computer architecture to form the central processing unit (CPU). The main architecture used for modern computers is the Von Neumann Architecture or Model.</p>"},{"location":"lessons/1_introduction/#von-neumann-architecture","title":"Von Neumann Architecture","text":"<p>The Von Neumann architecture falls at the \"Micro Architecture\" layer on our abstraction hierarchy and organizes the logic gates into components with concrete purposes to build a general computing platform. The components are:</p> <ul> <li>The Central Processing Unit (CPU) - The main computational workhorse, here the CPU reads machine instructions and executes them. It is made of two parts:<ul> <li>Control Unit - Used to sequence operations to be performed by the machine, orchestrating the other components</li> <li>Arithmetic/Logic Unit - Used to perform the instructions from the control unit on the memory unit</li> </ul> </li> <li>Memory Unit - A bank of memory that stores both instructions and data in the same address space</li> <li>Input Device - The source of information into the CPU, can be new instructions or data</li> <li>Output Device - Receives information from the CPU and routes it to other devices for control signals</li> </ul>"},{"location":"lessons/1_introduction/#programming-language-abstraction","title":"Programming Language Abstraction","text":"<p>While the Micro Architecture defines how instructions map operations done on memory, the Instruction Set Architecture (ISA) defines what instructions there are in the first place. These instructions are what the CPU will execute at the end of the day and is called machine code. Each individual instruction must be carefully picked and designed to be as fundamental as possible so that further functionalities can be built on top of them without later alteration. The two most popular instruction set architectures that you may know are:</p> <ul> <li>Intel's x86-64 instruction set - The current industry standard instruction set for most consumer PCs. Originally designed to only handle 32-bit length numbers (x86), but was later updated to support 64-bit numbers (x86-64). Owned by Intel, must pay them to create chips with it.</li> <li>RISC-V (\"risk-five\") - Reduced, optimized instruction set that sees use for environments where computational resources are constrained. Less widely used, but recently has seen more adoption. Open-sourced.</li> </ul> <p>This machine code is stored and read by the CPU in raw binary in order to be \"understood\". However, writing programs in raw binary is nearly impossible for a human to do in a reasonable amount of time. To make direct communication with the CPU easier, each machine code instruction was given an identifier written in characters that related to it purpose and a system of writing these more human-readable instructions into programs was developed, resulting in the creation of the Assembly Language.</p> <p></p> <p>Assembly language made it easier to develop programs, however the instructions were now no longer in a form that the CPU could understand. The CPU directly read instructions as binary codes, and as a result all instructions that intend to be ran must be in that form. This necessitated the creation of the assembler, a program that can convert assembly code into binary machine code. </p> <p>This idea of creating a level of representation on top of what you are actually doing on the computer for ease of use and development is yet another example of abstraction and working up the hierarchy. Every level above builds on top of assembly in some way, making it the lowest level of abstraction we as programmers can interact with normally. This puts it in a special place, an eventuality that every language designer and chip manufacturer should respect. As a result of this importance, it will be one of the focuses of this course and will be programmed in by the end of the semester.</p> <p>From assembly we build all other programming languages, for the purposes of this course we will focus on the C programming language primarily. This is due to the fact that C preserves certain low-level access that other languages hide away. C allows for direct memory access and its compilations object that are in assembly and machine code as easy to access. The next lesson will review programming in the C language and there will be a lab exploring these intermediate representations of your C programs.</p>"},{"location":"lessons/1_introduction/#optional-questions","title":"Optional Questions","text":"<ol> <li>You may have heard of \"Moore's Law\", if not look it up. Roughly describe it and, in your own words, indicate if you think the trend it identifies will continue or not. Justify your answer with why you think that or how you predict it will happen.</li> <li>In C, after you compile and run, you will get a <code>a.exe</code> or <code>a.out</code> file that actually runs your program. What level of the abstraction hierarchy do you think that is working in?</li> <li>With what you know about C, can you identify the parts of C that make it Turing-complete? From the criteria of being Turing-complete, can you think of how it is implemented in C?</li> </ol>"},{"location":"lessons/2_reviewing_c/","title":"C Review","text":"<p>This lessons covers:</p> <ul> <li>A general C review</li> <li>Compiled languages</li> <li>C datatypes, both primitive and composite</li> <li>Conditionals and loops</li> <li>The C Pre-Processor</li> <li>and introducing C++</li> </ul>"},{"location":"lessons/2_reviewing_c/#compilation","title":"Compilation","text":"<p>Before recalling the C syntax and semantics, we must first remember the domain we are working in and how programs are ran on a computer system. Computers cannot understand human languages without the power and water supply of a medium-sized town, meaning there must be intermediate steps to running our human-readable code on a computer.</p>"},{"location":"lessons/2_reviewing_c/#compilation-and-interpretation","title":"Compilation and Interpretation","text":"<p>The two main methods of getting a computer to run code are compilation and interpretation. </p> <p>Interpreted languages like Python and JavaScript are executed line-by-line by an interpreter at runtime. When you run a Python script, the interpreter reads each line, translates it to machine instructions, and executes it immediately. This makes development faster since you can test code quickly, but execution tends to be slower since the machine instructions are not always written in the most efficient manner out-of-the-box.</p> <p>Compiled languages, like C and C++, accomplish this task in a different way. Instead of being executed by and interpreter at runtime, C programs are compiled and converted to low-level machine code before runtime. Essentially, compiled languages are translated into machine code at compile time for the target system to produce an executable that can be ran without recompilation or interpretation. This leads to faster programs and more fine-grained control over what happens during the course of your program</p> <p>This process involves four primary steps:</p> <ol> <li>Preprocessing: The C preprocessor (CPP) formats the source code using macros like <code>#include</code> or <code>#define</code>, applying any user-defined changes before passing to the next step</li> <li>Compilation: The compiler translates C source code into assembly language</li> <li>Assembly: The assembler then converts the assembly code into machine code, producing object files, <code>.o</code> or <code>.obj</code>, as a result</li> <li>Linking: The linker orders the object files properly and combines them into a single executable program that is ready to run on the target system</li> </ol> <p>The following are the commands to compile a simple C program, using the GNU C Compiler: <pre><code># Compile source.c into an executable named program\ngcc source.c -o program\n# Run the executable\n./program\n</code></pre> In this simple program, all of the main steps are hidden from the user, however we can use compiler flags to view some of the intermediate files:</p> <ul> <li><code>-E</code>: Stops after preprocessing stage</li> <li><code>-S</code>: Stops compilation after generating assembly code</li> <li><code>-c</code>: Stops compilation after generating object files, preventing linking</li> </ul>"},{"location":"lessons/2_reviewing_c/#basics","title":"Basics","text":"<p>Now that we have reviewed how to compile and run our programs, let's go over the the fundamental building blocks of C programming.</p> <p>The following is a standard \"Hello World!\" program written in C: <pre><code>#include &lt;stdio.h&gt;\n\nint main(int argc, const char* argv[])\n{\n    printf(\"Hello CS240!\\n\");\n\n    return 0;\n}\n</code></pre></p> <ol> <li><code>#include &lt;stdio.h&gt;</code> - This is a preprocessor macro to include the <code>stdio.h</code> file at the beginning of this source code file.</li> <li><code>int main(){}</code> - The main function, our main entry point into executing code on the computer. The compiler runs this function in the final executable, making it responsible for orchestrating  all other functions.</li> <li><code>(int argc, const char* argv[])</code> - Command line arguments. When you run the program in the command-line, you may optionally give additional parameters to feed into your program, for example: <code>./program argument1 argument2</code>. <code>argc</code> and <code>argv</code> are variables that contain information about the command-line arguments. <code>argc</code><ol> <li><code>argc</code> - the number of arguments, including the filename of the executable<ol> <li>In the example above, it would take on the value 3</li> </ol> </li> <li><code>argv</code> - an array of char*'s to the actual string parameters passed</li> </ol> </li> <li><code>printf(\"Hello CS240!\\n\");</code> - This line represents a statement in C, an individual line of code. All statements in C must end in a semicolon <code>;</code>. This specific statement is calling a function from <code>stdio.h</code>, <code>printf();</code> which allows the programmer to print information to the screen.</li> <li><code>return 0;</code> - The return statement. When we defined <code>main();</code>, we put an <code>int</code> identifier before the function identifier. This defines the return type that is expected from our function, which is enforced by the compiler. When the return statement is ran the function ends and as will the entire program.  </li> </ol>"},{"location":"lessons/2_reviewing_c/#variables-and-data-types","title":"Variables and Data Types","text":"<p>Variables in C must be declared with a specific type before use. Unlike dynamically typed languages, C requires you to explicitly state what kind of data each variable will hold.</p> <p>The following is an example of declaring variables: <pre><code>#include &lt;stdio.h&gt;\n\nint main(int argc, const char* argv[])\n{\n    int num_books = 1000;      // Declaring an int type with a starting value\n    float average_length;      // Declaring a float type without a starting value\n\n\n    return 0;\n}\n</code></pre></p>"},{"location":"lessons/2_reviewing_c/#basic-data-types","title":"Basic Data Types","text":"<p>C provides several primitive data types:</p> <ul> <li>Integer Types: <code>int</code>, <code>short</code>, <code>long</code>, <code>long long</code><ul> <li>Typically <code>int</code> is 4 bytes (32 bits), ranging from -2,147,483,648 to 2,147,483,647</li> <li>Can be modified with <code>unsigned</code> for non-negative values only</li> </ul> </li> <li>Floating-Point Types: <code>float</code>, <code>double</code><ul> <li><code>float</code> is single-precision (4 bytes)</li> <li><code>double</code> is double-precision (8 bytes), preferred for most applications</li> </ul> </li> <li>Character Type: <code>char</code><ul> <li>1 byte, used for characters and small integers</li> <li>Characters are enclosed in single quotes: <code>'A'</code>, <code>'z'</code>, <code>'\\n'</code></li> </ul> </li> <li>Boolean Type: <code>bool</code> with <code>&lt;stdbool.h&gt;</code><ul> <li>Values are <code>true</code> or <code>false</code> Example declarations: <pre><code>int count = 0;\ndouble pi = 3.14159;\nchar grade = 'A';\nunsigned int positive_only = 42;\n</code></pre></li> </ul> </li> </ul>"},{"location":"lessons/2_reviewing_c/#composite-data-types","title":"Composite Data Types","text":"<p>Beyond basic types, C allows you to build more complex data structures:</p> <p>Arrays: Contiguous blocks of memory holding multiple elements of the same type <pre><code>int numbers[5] = {10, 20, 30, 40, 50};\nchar name[20] = \"Alice\";  // Strings are char arrays\n\n// Access elements by index (zero-indexed)\nint first = numbers[0];  // 10\nnumbers[2] = 35;         // Modify third element\n</code></pre> Arrays in C have fixed size and no bounds checking. Accessing an index outside the array's bounds leads to undefined behavior, a common source of bugs.</p> <p>Structures: Group related data of different types <pre><code>struct Student {\n    char name[50];\n    int id;\n    double gpa;\n};\n\nstruct Student alice;\nalice.id = 12345;\nalice.gpa = 3.8;\nstrcpy(alice.name, \"Alice Johnson\");\n</code></pre></p> <p>Pointers: Variables that store memory addresses <pre><code>int value = 42;\nint *ptr = &amp;value;  // ptr stores the address of value\n\nprintf(\"Value: %d\\n\", *ptr);  // Dereference to get value (42)\n*ptr = 100;  // Modify value through pointer\nprintf(\"New value: %d\\n\", value);  // Prints 100\n</code></pre> Pointers are powerful but dangerous. They enable dynamic memory allocation and efficient data manipulation, but incorrect pointer usage causes crashes, memory leaks, and security vulnerabilities.</p>"},{"location":"lessons/2_reviewing_c/#conditionals","title":"Conditionals","text":"<p>Conditionals allow your program to make decisions based on conditions.</p> <p>If-Else Statements <pre><code>int score = 85;\n\nif (score &gt;= 90) {\n    printf(\"Grade: A\\n\");\n} else if (score &gt;= 80) {\n    printf(\"Grade: B\\n\");\n} else if (score &gt;= 70) {\n    printf(\"Grade: C\\n\");\n} else {\n    printf(\"Grade: F\\n\");\n}\n</code></pre></p> <p>Switch Statements: Useful for multiple discrete cases <pre><code>char operation = '+';\nint a = 10, b = 5;\n\nswitch (operation) {\n    case '+':\n        printf(\"Result: %d\\n\", a + b);\n        break;\n    case '-':\n        printf(\"Result: %d\\n\", a - b);\n        break;\n    case '*':\n        printf(\"Result: %d\\n\", a * b);\n        break;\n    default:\n        printf(\"Unknown operation\\n\");\n}\n</code></pre> The <code>break</code> statement is crucial in switch cases to prevent fall-through to subsequent cases.</p>"},{"location":"lessons/2_reviewing_c/#loops","title":"Loops","text":"<p>Loops enable repetition of code blocks.</p> <p>For Loops: Best when the number of iterations is known <pre><code>// Print numbers 0 through 9\nfor (int i = 0; i &lt; 10; i++) {\n    printf(\"%d \", i);\n}\n\n// Iterate through an array\nint arr[5] = {2, 4, 6, 8, 10};\nfor (int i = 0; i &lt; 5; i++) {\n    printf(\"%d \", arr[i]);\n}\n</code></pre></p> <p>While Loops: Best when the number of iterations is unknown <pre><code>int count = 0;\nwhile (count &lt; 5) {\n    printf(\"Count: %d\\n\", count);\n    count++;\n}\n</code></pre></p> <p>Do-While Loops: Execute at least once, then check condition <pre><code>int input;\ndo {\n    printf(\"Enter a positive number: \");\n    scanf(\"%d\", &amp;input);\n} while (input &lt;= 0);\n</code></pre></p>"},{"location":"lessons/2_reviewing_c/#the-c-pre-processor-cpp","title":"The C Pre-Processor (CPP)","text":"<p>The C preprocessor runs before compilation and handles directives that begin with <code>#</code>. These directives modify your source code before it's compiled.</p> <p>Include Directive: Imports header files <pre><code>#include &lt;stdio.h&gt;   // System header (standard library)\n#include \"myheader.h\"  // User-defined header (local file)\n</code></pre></p> <p>Define Directive: Creates macros and constants <pre><code>#define PI 3.14159\n#define MAX_SIZE 100\n#define SQUARE(x) ((x) * (x))\n\n// Usage\ndouble area = PI * SQUARE(radius);\n</code></pre> Macros are simple text replacements. Notice the parentheses in <code>SQUARE(x)</code> to avoid unexpected behavior with operator precedence.</p> <p>Conditional Compilation: Include or exclude code based on conditions <pre><code>#define DEBUG\n\n#ifdef DEBUG\n    printf(\"Debug: x = %d\\n\", x);\n#endif\n\n#ifndef MAX_VALUE\n    #define MAX_VALUE 1000\n#endif\n</code></pre> This is useful for platform-specific code or enabling debug output during development.</p>"},{"location":"lessons/2_reviewing_c/#file-io-in-c","title":"File I/O in C","text":"<p>Programs often need to read from and write to files for persistent data storage. C provides a standard library interface for file operations through <code>&lt;stdio.h&gt;</code>.</p>"},{"location":"lessons/2_reviewing_c/#opening-and-closing-files","title":"Opening and Closing Files","text":"<p>Before reading or writing, you must open a file using <code>fopen()</code>:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    FILE *file = fopen(\"data.txt\", \"r\");  // Open for reading\n\n    if (file == NULL) {\n        printf(\"Error: Could not open file\\n\");\n        return 1;\n    }\n\n    // Use the file...\n\n    fclose(file);  // Always close when done\n    return 0;\n}\n</code></pre> <p>File modes determine how the file is accessed:</p> <ul> <li><code>\"r\"</code> - Read mode (file must exist)</li> <li><code>\"w\"</code> - Write mode (creates new file or overwrites existing)</li> <li><code>\"a\"</code> - Append mode (writes to end of file)</li> <li><code>\"r+\"</code> - Read and write (file must exist)</li> <li><code>\"w+\"</code> - Read and write (overwrites existing file)</li> <li><code>\"a+\"</code> - Read and append</li> </ul> <p>Always check if <code>fopen()</code> returns <code>NULL</code>, which indicates the file couldn't be opened. Common reasons include the file not existing (for read mode) or lacking permissions.</p>"},{"location":"lessons/2_reviewing_c/#reading-from-files","title":"Reading from Files","text":"<p>Character by character:</p> <pre><code>FILE *file = fopen(\"input.txt\", \"r\");\nchar ch;\n\nwhile ((ch = fgetc(file)) != EOF) {\n    printf(\"%c\", ch);\n}\n\nfclose(file);\n</code></pre> <p>Line by line:</p> <pre><code>FILE *file = fopen(\"input.txt\", \"r\");\nchar line[256];\n\nwhile (fgets(line, sizeof(line), file) != NULL) {\n    printf(\"%s\", line);\n}\n\nfclose(file);\n</code></pre> <p><code>fgets()</code> reads up to <code>n-1</code> characters or until a newline, whichever comes first. The newline character is included in the string if encountered.</p> <p>Formatted input:</p> <pre><code>FILE *file = fopen(\"scores.txt\", \"r\");\nchar name[50];\nint score;\n\nwhile (fscanf(file, \"%s %d\", name, &amp;score) == 2) {\n    printf(\"%s scored %d\\n\", name, score);\n}\n\nfclose(file);\n</code></pre> <p><code>fscanf()</code> works like <code>scanf()</code> but reads from a file instead of standard input. It returns the number of items successfully read.</p>"},{"location":"lessons/2_reviewing_c/#writing-to-files","title":"Writing to Files","text":"<p>Character by character:</p> <pre><code>FILE *file = fopen(\"output.txt\", \"w\");\n\nfputc('H', file);\nfputc('i', file);\nfputc('\\n', file);\n\nfclose(file);\n</code></pre> <p>Strings:</p> <pre><code>FILE *file = fopen(\"output.txt\", \"w\");\n\nfputs(\"Hello, World!\\n\", file);\nfputs(\"Writing to a file.\\n\", file);\n\nfclose(file);\n</code></pre> <p>Formatted output:</p> <pre><code>FILE *file = fopen(\"results.txt\", \"w\");\n\nfprintf(file, \"Student: %s\\n\", \"Alice\");\nfprintf(file, \"Score: %d\\n\", 95);\nfprintf(file, \"GPA: %.2f\\n\", 3.87);\n\nfclose(file);\n</code></pre> <p><code>fprintf()</code> works like <code>printf()</code> but writes to a file instead of standard output.</p>"},{"location":"lessons/2_reviewing_c/#practical-example","title":"Practical Example","text":"<p>Here's a complete program that reads student data from a file and calculates the average score:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    FILE *input = fopen(\"students.txt\", \"r\");\n    if (input == NULL) {\n        printf(\"Error opening input file\\n\");\n        return 1;\n    }\n\n    char name[50];\n    int score;\n    int total = 0;\n    int count = 0;\n\n    while (fscanf(input, \"%s %d\", name, &amp;score) == 2) {\n        printf(\"%s: %d\\n\", name, score);\n        total += score;\n        count++;\n    }\n\n    fclose(input);\n\n    if (count &gt; 0) {\n        double average = (double)total / count;\n\n        FILE *output = fopen(\"summary.txt\", \"w\");\n        fprintf(output, \"Total students: %d\\n\", count);\n        fprintf(output, \"Average score: %.2f\\n\", average);\n        fclose(output);\n\n        printf(\"\\nSummary written to summary.txt\\n\");\n    }\n\n    return 0;\n}\n</code></pre> <p>Remember: always close files with <code>fclose()</code> when finished. Failing to do so can result in data loss or resource leaks. The file pointer (<code>FILE *</code>) keeps track of your position in the file and manages buffering for efficient I/O operations.</p>"},{"location":"lessons/2_reviewing_c/#c-and-c","title":"C and C++","text":"<p>While this course uses both C and C++, it's important to understand their relationship.</p> <p>C++ was developed as an extension of C, adding features like classes, objects, templates, and exceptions while maintaining most of C's syntax. This means valid C code is often valid C++ code, but not always.</p> <p>The following are some immediate differences you'll have to work around.</p> <p>Function Declarations: C++ requires function prototypes before use; C is more lenient</p> <p>Input/Output: C++ introduces <code>iostream</code> with <code>cin</code> and <code>cout</code>, though C's <code>printf</code> and <code>scanf</code> still work</p> <p>Type Safety: C++ is stricter about type conversions <pre><code>// Valid in C, error in C++\nint *ptr = malloc(sizeof(int));  \n\n// C++ requires explicit cast\nint *ptr = (int*)malloc(sizeof(int));\n\n// Better: use C++ new operator\nint *ptr = new int;\n</code></pre></p> <p>As we progress through the course, we'll build on your C foundation to explore C++'s object-oriented features, which provide powerful tools for organizing complex programs and implementing sophisticated data structures.</p> <p>For now, ensure you're comfortable with these C fundamentals. They form the basis for everything we'll build in the coming weeks and we will explore more deeply on these differences later.</p>"},{"location":"lessons/3_binary_hex/","title":"Binary and Hexadecimal Numbers","text":"<p>In your previous courses in computer science, the idea of binary numbers must have come up at least once. However, until this point in your learning journey, you probably never had to understand it completely or why it is so deeply connected to computers. All information on the computer is ultimately stored in binary format, as we look deeper into the way a computer is made, we will need to be able to understand this representation of information to be better equipped for designing, fixing, or analyzing software.</p> <p>In this lesson, we will cover:</p> <ul> <li>Number systems generally</li> <li>A technical description of the decimal number system we all use</li> <li>The binary number system</li> <li>How to convert to and from binary and decimal</li> <li>The hexadecimal number system</li> <li>How to convert to and from hexadecimal and decimal</li> <li>How hexadecimal and binary connect to make reading raw data a little easier</li> <li>Important terms when speaking of numbers in different systems</li> </ul>"},{"location":"lessons/3_binary_hex/#number-systems","title":"Number Systems","text":"<p>When we want to communicate verbal information, we pick a system of speaking that formats that information, like a language, and express that information using the rules that the format/language defines. Ultimately that verbal information can be expressed in any format or language and still have the overall meaning but looks very different. Think about how you can say the same thing in any language:</p> <ul> <li>Ways to greet someone in many languages:<ul> <li>English: \"Hello\"</li> <li>Spanish: \"Hola\"</li> <li>Arabic: \"\u0645\u0631\u062d\u0628\u0627\u064b\"</li> <li>Swahili: \"Jambo\"</li> <li>Chinese: \"\u4f60\u597d\"</li> <li>Russian: \"\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439\u0442\u0435\"</li> </ul> </li> </ul> <p>Notice that they all mean the same thing, but the form in which they appear changes with the language/format. Each form has its own rules and symbols that inform how that information is received and understood. The information never changes but the form it takes and how many symbols it requires to be properly conveyed can be different.</p> <p>The above is the case for verbal information, but what about other kinds of information like numbers, audio, or video? What about a method of storing any kind of information, verbal or otherwise? Something that we will assume going forward is that all information can be represented using numbers, and as such we will focus on number systems. This assumption is the main idea of Information Theory as a field.</p> <p>A number system or numeral system is a method of representing values of numbers using a set of symbols or digits. The number system that you are most used to is the decimal number system also known as base-10, as we will see later. This is the standard way of representing numbers using the digits 0-9 for a total of ten digits, making its prefix \"deci-\" make sense.</p>"},{"location":"lessons/3_binary_hex/#the-decimal-number-system","title":"The Decimal Number System","text":"<p>The decimal number system isn't anything new to you and will be the \"lingua franka\" we translate back to when doing number conversions. Although you interact with these numbers every day, seldom does anyone stops to think why they are the way they are. To ensure we are on the same page on the mechanics of the base-10 system and as a means of introducing number systems generally, we will review.</p> <p>Digits are the symbols that numerical systems use to denote values. . For decimal, we have ten digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. These are the building blocks that construct all numbers.</p> <p>To represent values larger than nine, we use positional notation where each position represents a different weight. Each position is a power of 10:</p> Position 6 5 4 3 2 1 0 Power of 10 \\(10^6\\) \\(10^5\\) \\(10^4\\) \\(10^3\\) \\(10^2\\) \\(10^1\\) \\(10^0\\) Amount 1,000,000 100,000 10,000 1,000 100 10 1 Place Name Millions Hundred-Thousands Ten-Thousands Thousands Hundreds Tens Ones <p>Example: The number 90,621 breaks down as:</p> Position 4 3 2 1 0 Weight \\(10^4\\) \\(10^3\\) \\(10^2\\) \\(10^1\\) \\(10^0\\) Digit 9 0 6 2 1 \\[90621 = 9 \\times 10^4 + 0 \\times 10^3 + 6 \\times 10^2 + 2 \\times 10^1 + 1 \\times 10^0$$ $$= 90000 + 0 + 600 + 20 + 1 = 90621\\] <p>Here, ten is used as the base, hence the name base-10 system.</p>"},{"location":"lessons/3_binary_hex/#why-more-than-one","title":"Why more than one?","text":"<p>You may be asking yourself, \"Well yeah, but isn't that the only number system? Seems like common sense.\". You have a point in the day to day of normal life. Base-10 has become the single system that we use to represent numerical values for some time; however it is most definitely not universal. </p> <p>Historically, there have been many different kinds of number systems, sprung from different circumstances. Base-10 is a widespread system because we have an implicit knowledge of counting with 10, because of humanity's 10 fingers. However, one of the oldest formal number systems from civilization we have evidence of was a base-60 system from ancient Babylon. The Mayans created a vigesimal (base-20) system independently early in the time record, and tallying (writing numbers using a single symbol) could be thought of as the oldest number system and is technically base-1.</p> <p>Which number systems people use ultimately comes down to which system best fits their task and the medium in which that number system will be used. For the task of easily being able to represent numbers for a creature that's bad at math with ten fingers, base-10 becomes a good pick. However, sometimes the task or medium requires a different representation than base-10 for practicality. </p> <p>So there have been many other examples of different number systems using different digits and bases than what we use today. But how?</p>"},{"location":"lessons/3_binary_hex/#number-systems-generally","title":"Number Systems Generally","text":"<p>All number systems can be explained generally using its base number and its digits, for example here are the number systems we will be learning about along with base-10:</p> Number System Name Decimal Binary Hexadecimal Base Number 10 2 16 Digits 0,1,2,3,4,5,6,7,8,9 0,1 0-9, A,B,C,D,E,F <p>Notice that there are always base number of digits available to represent the number. Ultimately, it doesn't matter what symbols we use, so long as the base defines the number of unique symbols.</p>"},{"location":"lessons/3_binary_hex/#the-mathematical-description","title":"The Mathematical Description","text":"<p>For any number system with base \\(b\\), we can describe how to calculate the value of a number using the following components:</p> <p>Components of a Number System:</p> <ul> <li>Base (\\(b\\)): The number of unique digits in the system</li> <li>Digits: A set of \\(b\\) symbols, typically \\(0, 1, 2, ..., (b-1)\\)</li> <li>Positions: Each digit occupies a position, numbered from right to left starting at 0</li> </ul> <p>The General Formula:</p> <p>For a number with digits \\(d_n, d_{n-1}, d_{n-2}, ..., d_1, d_0\\) in base \\(b\\):</p> \\[\\text{Value} = d_n \\times b^n + d_{n-1} \\times b^{n-1} + d_{n-2} \\times b^{n-2} + ... + d_1 \\times b^1 + d_0 \\times b^0\\] <p>Or more compactly using summation notation:</p> \\[\\text{Value} = \\sum_{i=0}^{n} d_i \\times b^i\\] <p>Where:</p> <ul> <li>\\(d_i\\) is the digit at position \\(i\\)</li> <li>\\(b\\) is the base of the number system</li> <li>\\(i\\) is the position index (starting from 0 on the right)</li> <li>\\(n\\) is the position of the leftmost digit</li> </ul>"},{"location":"lessons/3_binary_hex/#examples","title":"Examples","text":"<p>Let's see how this general formula applies to different bases:</p>"},{"location":"lessons/3_binary_hex/#base-10-decimal","title":"Base-10 (Decimal)","text":"<ul> <li>Base: \\(b = 10\\)</li> <li>Digits: \\(0, 1, 2, 3, 4, 5, 6, 7, 8, 9\\) (10 total)</li> <li>Position weights: \\(10^0, 10^1, 10^2, 10^3, ...\\)</li> </ul> <p>For the number \\(90621_{10}\\):</p> \\[90621_{10} = 9 \\times 10^4 + 0 \\times 10^3 + 6 \\times 10^2 + 2 \\times 10^1 + 1 \\times 10^0\\] \\[= 90000 + 0 + 600 + 20 + 1 = 90621\\]"},{"location":"lessons/3_binary_hex/#base-5-quinary-an-example","title":"Base-5 (Quinary) - An Example","text":"<ul> <li>Base: \\(b = 5\\)</li> <li>Digits: \\(0, 1, 2, 3, 4\\) (5 total)</li> <li>Position weights: \\(5^0, 5^1, 5^2, 5^3, ...\\)</li> </ul> Position 3 2 1 0 Weight \\(5^3\\) \\(5^2\\) \\(5^1\\) \\(5^0\\) Amount 125 25 5 1 <p>For the number \\(1234_5\\) (read as \"one-two-three-four base five\"):</p> \\[1234_5 = 1 \\times 5^3 + 2 \\times 5^2 + 3 \\times 5^1 + 4 \\times 5^0\\] \\[= 1 \\times 125 + 2 \\times 25 + 3 \\times 5 + 4 \\times 1\\] \\[= 125 + 50 + 15 + 4 = 194_{10}\\] <p>So \\(1234_5 = 194_{10}\\), the same value, just represented differently.</p> <p>From this general description, we can identify several important principles that hold for all number systems:</p> <ol> <li> <p>The number of digits equals the base: A base-\\(b\\) system has exactly \\(b\\) unique digit symbols</p> </li> <li> <p>Digits range from 0 to (b-1): The largest single digit in base-\\(b\\) is always one less than the base itself</p> <ul> <li>Base-10: digits are 0\u20139</li> <li>Base-5: digits are 0\u20134</li> <li>Base-2: digits are 0\u20131</li> <li>Position value increases exponentially: Each position to the left is worth \\(b\\) times more than the position to its right</li> </ul> </li> <li> <p>The rightmost position is always \\(b^0 = 1\\): No matter the base, the ones place always exists</p> </li> <li> <p>Any value can be represented in any base: Just like how \"hello\" can be said in any language, any number can be written in any base</p> </li> </ol>"},{"location":"lessons/3_binary_hex/#the-binary-number-system","title":"The Binary Number System","text":"<p>With a general framework for all number systems, let's shrink back down to what we actually will be doing. Recall that all information on a computer is represented as binary numbers due to being made of transistors. This means all information must be represented using only two symbols, 0 and 1, for the transistors possible off and on state, respectively. This number system is therefore base-2 and is the reason it is called binary (prefix bi- meaning two). </p> <p>This results in the following table:</p> Number System Name Binary Base Number 2 Digits 0, 1 <p>Just like with decimal, binary uses positional notation where each position represents a power of 2:</p> Position 7 6 5 4 3 2 1 0 Power of 2 \\(2^7\\) \\(2^6\\) \\(2^5\\) \\(2^4\\) \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) Decimal Value 128 64 32 16 8 4 2 1 <p>Example: The binary number \\(1011_2\\) breaks down as:</p> Position 3 2 1 0 Weight \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) Digit 1 0 1 1 \\[1011_2 = 1 \\times 2^3 + 0 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0\\] \\[= 8 + 0 + 2 + 1 = 11_{10}\\] <p>So the binary number \\(1011_2\\) equals the decimal number \\(11_{10}\\).</p> <p>Notice that binary numbers get long very quickly. To represent the decimal number 255, you need eight binary digits: \\(11111111_2\\). This is one of the trade-offs of using a smaller base, you need more positions to represent the same values, but you only need to work with two symbols.</p>"},{"location":"lessons/3_binary_hex/#converting-from-decimal-to-binary","title":"Converting from Decimal to Binary","text":"<p>There are multiple methods to convert from decimal to binary, but the most straightforward is the division-by-2 method (also called the repeated division method).</p> <p>The Division-by-2 Method:</p> <ol> <li>Divide the decimal number by 2</li> <li>Record the remainder (this will be either 0 or 1)</li> <li>Divide the quotient from step 1 by 2</li> <li>Record the remainder</li> <li>Repeat until the quotient is 0</li> <li>Read the remainders from bottom to top this is your binary number</li> </ol> <p>Example: Convert \\(45_{10}\\) to binary</p> Step Division Quotient Remainder 1 45 \u00f7 2 22 1 \u2190 2 22 \u00f7 2 11 0 3 11 \u00f7 2 5 1 4 5 \u00f7 2 2 1 5 2 \u00f7 2 1 0 6 1 \u00f7 2 0 1 \u2191 <p>Reading the remainders from bottom to top: \\(101101_2\\)</p> <p>We can verify: \\(1 \\times 2^5 + 0 \\times 2^4 + 1 \\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0 = 32 + 8 + 4 + 1 = 45_{10}\\) \u2713</p> <p>Alternative Method: Subtraction Method</p> <p>Another approach is to subtract the largest power of 2 that fits into your number, working from left to right:</p> <p>Example: Convert \\(45_{10}\\) to binary</p> <ol> <li>Largest power of 2 \u2264 45 is \\(2^5 = 32\\). Place a 1 in position 5. Remainder: \\(45 - 32 = 13\\)</li> <li>Largest power of 2 \u2264 13 is \\(2^3 = 8\\). Place a 1 in position 3. Remainder: \\(13 - 8 = 5\\)</li> <li>Largest power of 2 \u2264 5 is \\(2^2 = 4\\). Place a 1 in position 2. Remainder: \\(5 - 4 = 1\\)</li> <li>Largest power of 2 \u2264 1 is \\(2^0 = 1\\). Place a 1 in position 0. Remainder: \\(1 - 1 = 0\\)</li> <li>Positions 4 and 1 were skipped, so they get 0s</li> </ol> <p>Result: \\(101101_2\\)</p> <p>Both methods give the same answer; use whichever makes more sense to you.</p>"},{"location":"lessons/3_binary_hex/#converting-from-binary-to-decimal","title":"Converting from Binary to Decimal","text":"<p>Converting from binary to decimal is more straightforward, we simply apply the general formula for number systems that we learned earlier.</p> <p>Method: Multiply each digit by its position weight (power of 2) and sum the results.</p> <p>Example 1: Convert \\(11010_2\\) to decimal</p> Position 4 3 2 1 0 Weight \\(2^4\\) \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) Digit 1 1 0 1 0 Value 16 8 0 2 0 \\[11010_2 = 1 \\times 16 + 1 \\times 8 + 0 \\times 4 + 1 \\times 2 + 0 \\times 1 = 16 + 8 + 2 = 26_{10}\\] <p>Example 2: Convert \\(10000001_2\\) to decimal</p> \\[10000001_2 = 1 \\times 2^7 + 0 \\times 2^6 + 0 \\times 2^5 + 0 \\times 2^4 + 0 \\times 2^3 + 0 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0\\] \\[= 128 + 1 = 129_{10}\\] <p>Quick Tip: You only need to add the positions where the digit is 1. All the 0s contribute nothing to the sum, so you can skip them entirely.</p>"},{"location":"lessons/3_binary_hex/#the-hexadecimal-number-system","title":"The Hexadecimal Number System","text":"<p>While binary is the language computers speak natively, it has a significant drawback for human use: binary numbers get extremely long very quickly. The number \\(11111111111111111111111111111111_2\\) is hard to read, hard to remember, and easy to make mistakes with. This is where hexadecimal comes in.</p> <p>Hexadecimal (often shortened to hex) is a base-16 number system. The prefix \"hexa-\" means six and \"decimal\" means ten, so hexadecimal literally means \"six and ten\" or sixteen. Hexadecimal provides a much more compact way to represent binary data while still being easy to convert back and forth.</p> <p>The challenge with base-16 is that we need 16 unique digits, but we only have 10 numerical symbols (0-9). The solution? We borrow from the alphabet. The digits A through F represent the values 10 through 15:</p> Number System Name Hexadecimal Base Number 16 Digits 0-9, A,B,C,D,E,F <p>Here's how the hexadecimal digits map to decimal values:</p> Hex Digit 0 1 2 3 4 5 6 7 8 9 A B C D E F Decimal 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 <p>Just like decimal and binary, hexadecimal uses positional notation with powers of 16:</p> Position 4 3 2 1 0 Power of 16 \\(16^4\\) \\(16^3\\) \\(16^2\\) \\(16^1\\) \\(16^0\\) Decimal Value 65,536 4,096 256 16 1 <p>Example: The hexadecimal number \\(2A3F_{16}\\) breaks down as:</p> Position 3 2 1 0 Weight \\(16^3\\) \\(16^2\\) \\(16^1\\) \\(16^0\\) Digit 2 A 3 F Value 2 10 3 15 \\[2A3F_{16} = 2 \\times 16^3 + 10 \\times 16^2 + 3 \\times 16^1 + 15 \\times 16^0\\] \\[= 2 \\times 4096 + 10 \\times 256 + 3 \\times 16 + 15 \\times 1\\] \\[= 8192 + 2560 + 48 + 15 = 10815_{10}\\] <p>Notice how much more compact hexadecimal is compared to binary. The decimal number 10,815 would be \\(10101000111111_2\\) in binary (14 digits), but only \\(2A3F_{16}\\) in hexadecimal (4 digits).</p>"},{"location":"lessons/3_binary_hex/#converting-from-decimal-to-hexadecimal","title":"Converting from Decimal to Hexadecimal","text":"<p>Just like with binary, we use the division method, but this time we divide by 16.</p> <p>The Division-by-16 Method:</p> <ol> <li>Divide the decimal number by 16</li> <li>Record the remainder (this will be 0-15; use A-F for 10-15)</li> <li>Divide the quotient from step 1 by 16</li> <li>Record the remainder</li> <li>Repeat until the quotient is 0</li> <li>Read the remainders from bottom to top, this is your hexadecimal number</li> </ol> <p>Example: Convert \\(2748_{10}\\) to hexadecimal</p> Step Division Quotient Remainder (Decimal) Remainder (Hex) 1 2748 \u00f7 16 171 12 C \u2190 2 171 \u00f7 16 10 11 B 3 10 \u00f7 16 0 10 A \u2191 <p>Reading the remainders from bottom to top: \\(ABC_{16}\\)</p> <p>We can verify: \\(10 \\times 16^2 + 11 \\times 16^1 + 12 \\times 16^0 = 2560 + 176 + 12 = 2748_{10}\\) \u2713</p> <p>Example 2: Convert \\(255_{10}\\) to hexadecimal</p> Step Division Quotient Remainder (Decimal) Remainder (Hex) 1 255 \u00f7 16 15 15 F \u2190 2 15 \u00f7 16 0 15 F \u2191 <p>Result: \\(FF_{16}\\)</p> <p>This is a number you'll see frequently in computer science. \\(FF_{16}\\) represents the maximum value that can be stored in 8 bits.</p>"},{"location":"lessons/3_binary_hex/#converting-from-hexadecimal-to-decimal","title":"Converting from Hexadecimal to Decimal","text":"<p>Converting from hexadecimal to decimal follows the same pattern as binary to decimal.</p> <p>Method: Multiply each digit by its position weight (power of 16) and sum the results. Remember to convert A-F to their decimal equivalents (10-15) before multiplying.</p> <p>Example 1: Convert \\(1F4_{16}\\) to decimal</p> Position 2 1 0 Weight \\(16^2\\) \\(16^1\\) \\(16^0\\) Digit 1 F 4 Value 1 15 4 \\[1F4_{16} = 1 \\times 256 + 15 \\times 16 + 4 \\times 1 = 256 + 240 + 4 = 500_{10}\\] <p>Example 2: Convert \\(DEAD_{16}\\) to decimal</p> \\[DEAD_{16} = 13 \\times 16^3 + 10 \\times 16^2 + 10 \\times 16^1 + 13 \\times 16^0\\] \\[= 13 \\times 4096 + 10 \\times 256 + 10 \\times 16 + 13 \\times 1\\] \\[= 53248 + 2560 + 160 + 13 = 57005_{10}\\]"},{"location":"lessons/3_binary_hex/#the-connection-between-binary-and-hexadecimal","title":"The Connection Between Binary and Hexadecimal","text":"<p>Here's where hexadecimal becomes truly useful: there's a remarkably simple relationship between binary and hexadecimal that makes conversion between them trivial. This is because 16 is a power of 2: \\(16 = 2^4\\).</p> <p>This means that one hexadecimal digit perfectly represents exactly four binary digits. This 4-to-1 mapping is what makes hexadecimal so practical for representing binary data.</p> <p>Here's the complete mapping:</p> Hex Binary Decimal Hex Binary Decimal 0 0000 0 8 1000 8 1 0001 1 9 1001 9 2 0010 2 A 1010 10 3 0011 3 B 1011 11 4 0100 4 C 1100 12 5 0101 5 D 1101 13 6 0110 6 E 1110 14 7 0111 7 F 1111 15 <p>Converting Binary to Hexadecimal:</p> <ol> <li>Group the binary digits into sets of 4, starting from the right</li> <li>If the leftmost group has fewer than 4 digits, pad with zeros on the left</li> <li>Convert each group of 4 binary digits to its hexadecimal equivalent</li> <li>Concatenate the hex digits</li> </ol> <p>Example 1: Convert \\(11010111_2\\) to hexadecimal</p> <ol> <li>Group into fours: \\(1101\\) \\(0111\\)</li> <li>Convert each group:<ul> <li>\\(1101_2 = D_{16}\\)</li> <li>\\(0111_2 = 7_{16}\\)</li> </ul> </li> <li>Result: \\(D7_{16}\\)</li> </ol> <p>Example 2: Convert \\(1011111010_2\\) to hexadecimal</p> <ol> <li>Group into fours from right: \\(10\\) \\(1111\\) \\(1010\\)</li> <li>Pad the leftmost group: \\(0010\\) \\(1111\\) \\(1010\\)</li> <li>Convert each group:<ul> <li>\\(0010_2 = 2_{16}\\)</li> <li>\\(1111_2 = F_{16}\\)</li> <li>\\(1010_2 = A_{16}\\)</li> </ul> </li> <li>Result: \\(2FA_{16}\\)</li> </ol> <p>Converting Hexadecimal to Binary:</p> <p>This is even easier, just replace each hex digit with its 4-bit binary equivalent.</p> <p>Example 1: Convert \\(3C_{16}\\) to binary</p> <ul> <li>\\(3_{16} = 0011_2\\)</li> <li>\\(C_{16} = 1100_2\\)</li> <li>Result: \\(00111100_2\\) (or \\(111100_2\\) without leading zeros)</li> </ul> <p>Example 2: Convert \\(BEEF_{16}\\) to binary</p> <ul> <li>\\(B_{16} = 1011_2\\)</li> <li>\\(E_{16} = 1110_2\\)</li> <li>\\(E_{16} = 1110_2\\)</li> <li>\\(F_{16} = 1111_2\\)</li> <li>Result: \\(1011111011101111_2\\)</li> </ul> <p>This direct conversion is why hexadecimal is so popular in computer science. Instead of writing out 32 or 64 binary digits, programmers can write 8 or 16 hex digits and convert trivially when needed. It's a human-friendly notation for machine-friendly data.</p>"},{"location":"lessons/3_binary_hex/#important-terms","title":"Important Terms","text":"<p>Now that we understand binary and hexadecimal number systems, there are several important terms used in computer science when working with these representations. These terms describe specific quantities and groupings of binary digits that are fundamental to how computers organize and process data.</p>"},{"location":"lessons/3_binary_hex/#bit","title":"Bit","text":"<p>A bit (short for binary digit) is the smallest unit of data in a computer. It can have only two possible values: 0 or 1. This directly corresponds to the two states of a transistor: off or on, no voltage or voltage, false or true.</p> <p>Everything in a computer, everything from numbers, letters, images, videos, or even programs, are all ultimately represented as a collection of bits. When we say a computer is \"digital,\" we mean it works exclusively with these discrete binary values.</p> <p>Examples:</p> <ul> <li>The binary number \\(1011_2\\) consists of 4 bits</li> <li>A single bit can represent: on/off, true/false, yes/no</li> <li>The letter 'A' in ASCII is represented as \\(01000001_2\\), which is 8 bits</li> </ul>"},{"location":"lessons/3_binary_hex/#nibble","title":"Nibble","text":"<p>A nibble (sometimes spelled nybble) is a group of exactly 4 bits. The term is a playful reference to a nibble being half of a byte (which we'll discuss next).</p> <p>Nibbles are particularly important because of their relationship to hexadecimal: one nibble corresponds exactly to one hexadecimal digit, as we saw in the previous section.</p> <p>Examples:</p> <ul> <li>The binary number \\(1011_2\\) is one nibble</li> <li>The binary number \\(11010111_2\\) consists of two nibbles: \\(1101\\) and \\(0111\\)</li> <li>The hexadecimal digit \\(F_{16}\\) represents the nibble \\(1111_2\\)</li> </ul> <p>Why Nibbles Matter:</p> <ul> <li>Each hexadecimal digit represents exactly one nibble</li> <li>This makes it easy to visually convert between binary and hex</li> <li>Nibbles are often used when working with binary-coded decimal (BCD) systems</li> <li>They're useful for representing single hexadecimal digits in hardware</li> </ul>"},{"location":"lessons/3_binary_hex/#byte","title":"Byte","text":"<p>A byte is a group of 8 bits and is the fundamental unit of memory in most modern computers. Almost all computer operations, memory addressing, and data storage are organized around bytes.</p> <p>The byte is important enough that it's the standard unit used to measure computer memory and storage capacity. When you see kilobytes (KB), megabytes (MB), or gigabytes (GB), these are all based on bytes.</p> <p>Examples:</p> <ul> <li>The binary number \\(11010111_2\\) is one byte</li> <li>One byte can represent decimal values from \\(0\\) to \\(255\\) (or \\(00000000_2\\) to \\(11111111_2\\))</li> <li>The hexadecimal number \\(FF_{16}\\) represents one byte with all bits set to 1</li> <li>One ASCII character is stored in exactly one byte</li> </ul> <p>Why Bytes Matter:</p> <ul> <li>Memory addresses typically point to byte locations</li> <li>Most data types are measured in bytes (e.g., a 32-bit integer is 4 bytes)</li> <li>File sizes are measured in bytes and their multiples</li> <li>One byte can represent 256 different values (\\(2^8 = 256\\))</li> </ul> <p>Important Note: A byte always has exactly 8 bits. This wasn't always universal historically (some early computers used different byte sizes), but 8 bits per byte has been the standard since the 1960s and is essentially universal today.</p>"},{"location":"lessons/3_binary_hex/#word","title":"Word","text":"<p>A word is the natural unit of data used by a particular computer architecture. Unlike bit, nibble, and byte, which have fixed sizes, a word's size varies depending on the processor design.</p> <p>The word size determines several important characteristics of a computer:</p> <ul> <li>How much data the processor can handle in a single operation</li> <li>The maximum memory address the processor can directly access</li> <li>The size of the processor's registers</li> </ul> <p>Common Word Sizes:</p> <ul> <li>8-bit processors: 1 byte (8 bits) <ul> <li>early microprocessors like the Intel 8080</li> </ul> </li> <li>16-bit processors: 2 bytes (16 bits)  <ul> <li>processors like the Intel 8086</li> </ul> </li> <li>32-bit processors: 4 bytes (32 bits) <ul> <li>common in desktops from the 1990s-2000s</li> </ul> </li> <li>64-bit processors: 8 bytes (64 bits) <ul> <li>standard in modern computers today</li> </ul> </li> </ul> <p>Examples:</p> <ul> <li>On a 32-bit system, a word is \\(32\\) bits or \\(4\\) bytes</li> <li>On a 64-bit system, a word is \\(64\\) bits or \\(8\\) bytes</li> <li>A 64-bit processor can process a word like \\(0xFFFFFFFFFFFFFFFF_{16}\\) in a single operation</li> </ul> <p>Why Word Size Matters:</p> <ul> <li>Determines the maximum amount of RAM that can be directly addressed<ul> <li>32-bit: Can address up to \\(2^{32}\\) bytes = 4 GB of RAM</li> <li>64-bit: Can address up to \\(2^{64}\\) bytes = 16 exabytes of RAM (theoretically)</li> </ul> </li> <li>Affects the precision of integer arithmetic operations</li> <li>Influences overall system performance and architecture design</li> </ul>"},{"location":"lessons/3_binary_hex/#most-significant-bit-msb-and-least-significant-bit-lsb","title":"Most Significant Bit (MSB) and Least Significant Bit (LSB)","text":"<p>In any binary number, the bits have different levels of importance based on their position. The most significant bit (MSB) is the bit in the highest-value position (leftmost), while the least significant bit (LSB) is the bit in the lowest-value position (rightmost).</p> <p>Example: In the byte \\(10110011_2\\)</p> <pre><code>  MSB                    LSB\n   \u2193                      \u2193\n   1  0  1  1  0  0  1  1\n  128 64 32 16  8  4  2  1  \u2190 position values\n</code></pre> <ul> <li>The MSB is \\(1\\) (leftmost), representing \\(128_{10}\\)</li> <li>The LSB is \\(1\\) (rightmost), representing \\(1_{10}\\)</li> <li>Changing the MSB changes the value by 128</li> <li>Changing the LSB changes the value by only 1</li> </ul> <p>Why MSB and LSB Matter:</p> <ul> <li>The MSB in signed integers often represents the sign (positive/negative)</li> <li>The LSB is important for parity checks and determining even/odd</li> <li>Bit ordering (endianness) refers to whether MSB or LSB is stored first in memory</li> <li>When doing bit shifts, knowing which end is which is crucial</li> </ul>"},{"location":"lessons/3_binary_hex/#number-notation-conventions","title":"Number Notation Conventions","text":"<p>When writing numbers in different bases, it's essential to indicate which base you're using to avoid confusion. There are several common conventions:</p> <p>Subscript Notation:</p> <ul> <li>\\(10111_2\\) means the number 10111 in binary (base-2)</li> <li>\\(2F_{16}\\) means the number 2F in hexadecimal (base-16)</li> <li>\\(156_{10}\\) means the number 156 in decimal (base-10)</li> </ul> <p>This is the notation used in mathematical contexts and in this document.</p> <p>Prefix Notation (Programming):</p> <ul> <li><code>0b10111</code> or <code>0B10111</code> -  binary (used in Python, C++14 and later, and others)</li> <li><code>0x2F</code> or <code>0X2F</code> - hexadecimal (used in C, C++, Java, Python, and many others)</li> <li><code>0o177</code> or <code>0O177</code> - octal, base-8 (used in Python and some others)</li> <li>No prefix typically means decimal</li> </ul> <p>Examples in Code:</p> <pre><code>binary_num = 0b10111;     # Binary: 23 in decimal\nhex_num = 0x2F;           # Hexadecimal: 47 in decimal\ndecimal_num = 156;        # Decimal: 156\n</code></pre> <p>Suffix Notation:</p> <ul> <li>Sometimes you'll see <code>10111b</code> or <code>2Fh</code> to indicate binary and hexadecimal</li> <li>This is less common but appears in some assembly languages and documentation</li> </ul> <p>Context Matters: When working with computer systems, pay attention to the notation being used. A number like \\(10110\\) could mean:</p> <ul> <li>Ten thousand, one hundred ten in decimal</li> <li>Twenty-two in binary (\\(10110_2 = 22_{10}\\))</li> <li>Sixty-six thousand, five hundred seventy-six in hexadecimal (\\(10110_{16} = 66576_{10}\\))</li> </ul> <p>Always check for subscripts, prefixes, or context clues to determine the intended base.</p>"},{"location":"lessons/3_binary_hex/#summary-table","title":"Summary Table","text":"<p>Here's a quick reference for these important terms:</p> Term Size Description Example Bit 1 bit Smallest unit; single binary digit (0 or 1) \\(1\\) Nibble 4 bits Half a byte; one hex digit \\(1011_2 = B_{16}\\) Byte 8 bits Standard unit of memory; two hex digits \\(11010111_2 = D7_{16}\\) Word Varies by architecture Natural processing unit (32 or 64 bits typically) 4 or 8 bytes MSB Single bit Leftmost bit; highest value position The \\(1\\) in \\(1011\\) LSB Single bit Rightmost bit; lowest value position The \\(1\\) in \\(1010\\) <p>Understanding these terms is essential for working with computer hardware, low-level programming, network protocols, and data structures. They form the vocabulary that computer scientists and engineers use to discuss how computers represent and manipulate data at the most fundamental level.</p>"}]}